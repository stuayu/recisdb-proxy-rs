<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>BonDriver Integrated Implementation Plan</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="bondriver-integrated-implementation-plan">BonDriver Integrated Implementation Plan</h1>
<h2 id="自動チャンネルスキャン--db保存--ネットワークプロキシ-統合実装計画">自動チャンネルスキャン + DB保存 + ネットワークプロキシ 統合実装計画</h2>
<h2 id="概要">概要</h2>
<p>既存の <code>docs/BonDriverAutoScanPlan.md</code> と <code>docs/BonDriverProxyPlan.md</code> の2つの計画を統合し、以下の全プロジェクトを書き換える計画です。</p>
<h3 id="統合プロジェクト一覧">統合プロジェクト一覧</h3>
<ol>
<li><strong>既存プロジェクト</strong>: <code>b25-sys</code>, <code>recisdb-rs</code></li>
<li><strong>新規プロジェクト</strong>: <code>recisdb-protocol</code>, <code>recisdb-proxy</code>, <code>bondriver-proxy-client</code></li>
</ol>
<hr>
<h2 id="1-新規プロジェクト構成">1. 新規プロジェクト構成</h2>
<pre><code>recisdb-rs/                    # ワークスペースルート
├── Cargo.toml                 # ワークスペース設定
├── .gitignore
│
├── b25-sys/                   # 既存：ARIB-B25デコード
│   └── 変更なし
│
├── recisdb-rs/                # 既存：メインCLI
│   ├── Cargo.toml             # 拡張：依存関係追加
│   ├── src/
│   │   ├── main.rs           # 拡張：新コマンド追加
│   │   ├── context.rs        # 拡張：新コマンド定義
│   │   ├── channels.rs       # 拡張：DB-backed ChannelType追加
│   │   ├── tuner/            # 拡張：DB統合
│   │   ├── commands/         # 拡張：scan/show/query追加
│   │   └── database/         # **新規**：DBモジュール
│   │       ├── mod.rs
│   │       ├── models.rs
│   │       ├── bon_driver.rs
│   │       ├── channel.rs
│   │       └── scan_history.rs
│   │
│   ├── src/ts_analyzer/      # **新規**：TS解析モジュール
│   │   └── mod.rs
│   │
│   └── src/ts_extractor/     # **新規**：TS抽出モジュール
│       └── mod.rs
│
├── recisdb-protocol/          # **新規**：プロトコル定義
│   ├── Cargo.toml
│   └── src/
│       ├── lib.rs
│       ├── types.rs              # メッセージ型、ChannelInfo、ChannelSelector
│       ├── codec.rs              # エンコード/デコード
│       ├── broadcast_region.rs   # NID→放送種別・地域判定
│       └── error.rs
│
├── recisdb-proxy/             # **新規**：サーバー
│   ├── Cargo.toml
│   ├── recisdb-proxy.toml.example
│   └── src/
│       ├── main.rs
│       ├── server/
│       │   ├── listener.rs
│       │   └── session.rs
│       ├── tuner/
│       │   ├── pool.rs
│       │   ├── shared.rs
│       │   ├── channel_key.rs
│       │   ├── lock.rs              # 排他/共有ロック管理
│       │   ├── selector.rs          # チューナー自動選択（フォールバック付き）
│       │   └── passive_scanner.rs   # パッシブスキャン（配信中更新）
│       ├── scheduler/
│       │   └── scan_scheduler.rs    # 定期スキャンスケジューラー
│       └── database/          # データベースモジュール
│           ├── mod.rs
│           ├── bon_driver.rs
│           ├── channel.rs
│           └── scan_history.rs
│
└── bondriver-proxy-client/    # **新規**：クライアントDLL
    ├── Cargo.toml
    ├── build.rs
    └── src/
        ├── lib.rs
        ├── bondriver/
        │   ├── interface.rs
        │   └── exports.rs
        └── client/
            ├── connection.rs
            └── buffer.rs
</code></pre>
<hr>
<h2 id="2-統合アーキテクチャ設計">2. 統合アーキテクチャ設計</h2>
<h3 id="21-データベースの統合">2.1 データベースの統合</h3>
<p>AutoScan計画のデータベース設計を基に、Proxy計画でも共用する。</p>
<p><strong>利用ファイル</strong>: <code>recisdb-protocol/src/types.rs</code></p>
<pre><code class="language-rust"><span class="hljs-comment">/// チャンネル情報（共用型）</span>
<span class="hljs-meta">#[derive(Debug, Clone, Serialize, Deserialize)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ChannelInfo</span> {
    <span class="hljs-comment">// 一意識別キー (NID-SID-TSID-manual_sheet)</span>
    <span class="hljs-keyword">pub</span> nid: <span class="hljs-type">u16</span>,                        <span class="hljs-comment">// Network ID (SDTから取得)</span>
    <span class="hljs-keyword">pub</span> sid: <span class="hljs-type">u16</span>,                        <span class="hljs-comment">// Service ID</span>
    <span class="hljs-keyword">pub</span> tsid: <span class="hljs-type">u16</span>,                       <span class="hljs-comment">// Transport Stream ID</span>
    <span class="hljs-keyword">pub</span> manual_sheet: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u16</span>&gt;,       <span class="hljs-comment">// ユーザー定義枝番 (None=標準)</span>

    <span class="hljs-comment">// チャンネル情報</span>
    <span class="hljs-keyword">pub</span> raw_name: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,        <span class="hljs-comment">// 生のサービス名 (ARIB文字列)</span>
    <span class="hljs-keyword">pub</span> channel_name: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,    <span class="hljs-comment">// 正規化されたチャンネル名</span>
    <span class="hljs-keyword">pub</span> physical_ch: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u8</span>&gt;,         <span class="hljs-comment">// 物理チャンネル番号 (NITから取得)</span>
    <span class="hljs-keyword">pub</span> remote_control_key: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u8</span>&gt;,  <span class="hljs-comment">// リモコンキーID (NITから取得)</span>
    <span class="hljs-keyword">pub</span> service_type: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u8</span>&gt;,        <span class="hljs-comment">// サービス種別 (0x01=TV, 0x02=Radio)</span>
    <span class="hljs-keyword">pub</span> network_name: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,    <span class="hljs-comment">// ネットワーク名 (NITから取得)</span>

    <span class="hljs-comment">// BonDriver固有情報 (スキャン時に記録)</span>
    <span class="hljs-keyword">pub</span> bon_space: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u32</span>&gt;,          <span class="hljs-comment">// BonDriverのSpace番号</span>
    <span class="hljs-keyword">pub</span> bon_channel: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u32</span>&gt;,        <span class="hljs-comment">// BonDriverのChannel番号</span>
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">ChannelInfo</span> {
    <span class="hljs-comment">/// 一意識別キーを生成</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">unique_key</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">u16</span>, <span class="hljs-type">u16</span>, <span class="hljs-type">u16</span>, <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u16</span>&gt;) {
        (<span class="hljs-keyword">self</span>.nid, <span class="hljs-keyword">self</span>.sid, <span class="hljs-keyword">self</span>.tsid, <span class="hljs-keyword">self</span>.manual_sheet)
    }

    <span class="hljs-comment">/// NID-SID-TSIDのみで比較（manual_sheetを無視）</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">service_key</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">u16</span>, <span class="hljs-type">u16</span>, <span class="hljs-type">u16</span>) {
        (<span class="hljs-keyword">self</span>.nid, <span class="hljs-keyword">self</span>.sid, <span class="hljs-keyword">self</span>.tsid)
    }
}
</code></pre>
<p><strong>モジュール構成</strong>:</p>
<ul>
<li><code>recisdb-rs/src/database/</code> - ローカルDB操作（CLI）</li>
<li><code>recisdb-proxy/src/database/</code> - サーバーDB操作（Proxy）</li>
</ul>
<h3 id="22-channeltype-の統合">2.2 ChannelType の統合</h3>
<p>既存の <code>channels.rs</code> を拡張し、DB-backedチャンネルをサポート。</p>
<p><strong>変更ファイル</strong>: <code>recisdb-rs/src/channels.rs</code></p>
<pre><code class="language-rust"><span class="hljs-meta">#[derive(Debug, Clone, PartialEq, Eq)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ChannelType</span> {
    <span class="hljs-comment">// 既存型</span>
    <span class="hljs-title function_ invoke__">Terrestrial</span>(<span class="hljs-type">u8</span>, TsFilter),
    <span class="hljs-title function_ invoke__">Catv</span>(<span class="hljs-type">u8</span>, TsFilter),
    <span class="hljs-title function_ invoke__">BS</span>(<span class="hljs-type">u8</span>, TsFilter),
    <span class="hljs-title function_ invoke__">CS</span>(<span class="hljs-type">u8</span>, TsFilter),
    <span class="hljs-title function_ invoke__">BonCh</span>(<span class="hljs-type">u8</span>),
    <span class="hljs-title function_ invoke__">BonChSpace</span>(ChannelSpace),
    Undefined,
    
    <span class="hljs-comment">// **新規**: DB-backed型</span>
    Db {
        nid: <span class="hljs-type">u16</span>,
        sid: <span class="hljs-type">u16</span>,
        tsid: <span class="hljs-type">u16</span>,
        manual_sheet: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u16</span>&gt;,
    },
}
</code></pre>
<p><strong>機能拡張</strong>:</p>
<ul>
<li><code>ChannelType::from_db_info()</code> - DB情報からChannelType生成</li>
<li><code>ChannelType::to_db_key()</code> - DBキー変換</li>
<li>既存の <code>ChannelType::BS()</code> と <code>ChannelType::Db</code> の相互変換</li>
</ul>
<h3 id="23-依存関係管理">2.3 依存関係管理</h3>
<p><strong>競合リスク</strong>:</p>
<ul>
<li>既存: <code>futures-util</code>, <code>nom</code>, <code>clap</code></li>
<li>AutoScan追加: <code>rusqlite</code>, <code>serde</code>, <code>prettytable-rs</code>, <code>bitstream-io</code></li>
<li>Proxy追加: <code>tokio-rustls</code>, <code>rustls</code>, <code>tokio</code>（フルasync）</li>
</ul>
<p><strong>解決策</strong>: ワークスペースレベルで依存を統合管理</p>
<p><strong>追加依存関係</strong> (recisdb-rs/Cargo.toml):</p>
<pre><code class="language-toml"><span class="hljs-comment"># データベース関連</span>
<span class="hljs-attr">rusqlite</span> = { version = <span class="hljs-string">&quot;0.31&quot;</span>, features = [<span class="hljs-string">&quot;bundled&quot;</span>] }
<span class="hljs-attr">serde</span> = { version = <span class="hljs-string">&quot;1.0&quot;</span>, features = [<span class="hljs-string">&quot;derive&quot;</span>] }
<span class="hljs-attr">serde_json</span> = <span class="hljs-string">&quot;1.0&quot;</span>
<span class="hljs-attr">prettytable-rs</span> = <span class="hljs-string">&quot;0.10&quot;</span>
<span class="hljs-attr">bitstream-io</span> = <span class="hljs-string">&quot;0.2&quot;</span>

<span class="hljs-comment"># 非同期関連</span>
<span class="hljs-attr">tokio</span> = { version = <span class="hljs-string">&quot;1&quot;</span>, features = [<span class="hljs-string">&quot;full&quot;</span>] }
<span class="hljs-attr">tokio-rustls</span> = <span class="hljs-string">&quot;0.25&quot;</span>
<span class="hljs-attr">rustls</span> = <span class="hljs-string">&quot;0.22&quot;</span>
</code></pre>
<h3 id="24-既存apiとの互換性">2.4 既存APIとの互換性</h3>
<p><strong>課題</strong>: 既存の <code>Tuner</code> enum と <code>AsyncInOutTriple</code> が、DB-backedチューニングとProxyを統合するか。</p>
<p><strong>解決案</strong>:</p>
<h4 id="241-tuner-enum-の拡張">2.4.1 Tuner Enum の拡張</h4>
<pre><code class="language-rust"><span class="hljs-comment">// recisdb-rs/src/tuner/mod.rs</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Tuner</span> {
    <span class="hljs-meta">#[cfg(target_os = <span class="hljs-string">&quot;linux&quot;</span>)]</span>
    <span class="hljs-title function_ invoke__">Character</span>(character_device::Tuner),
    <span class="hljs-meta">#[cfg(target_os = <span class="hljs-string">&quot;linux&quot;</span>)]</span>
    <span class="hljs-title function_ invoke__">DvbV5</span>(dvbv5::Tuner),
    <span class="hljs-meta">#[cfg(target_os = <span class="hljs-string">&quot;windows&quot;</span>)]</span>
    <span class="hljs-title function_ invoke__">BonDriver</span>(windows::Tuner),
    
    <span class="hljs-comment">// **新規**: DB-backedチューニング</span>
    <span class="hljs-meta">#[cfg(feature = <span class="hljs-string">&quot;database&quot;</span>)]</span>
    <span class="hljs-title function_ invoke__">Database</span>(database::DatabaseTuner),
}
</code></pre>
<h4 id="242-asyncinouttriple-の拡張">2.4.2 AsyncInOutTriple の拡張</h4>
<pre><code class="language-rust"><span class="hljs-comment">// recisdb-rs/src/io.rs</span>
<span class="hljs-keyword">impl</span>&lt;R, D, W&gt; AsyncInOutTriple&lt;R, D, W&gt; 
<span class="hljs-keyword">where</span>
    R: AsyncRead + Unpin,
    D: StreamDecoder,
    W: AsyncWrite + Unpin,
{
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new_tune_with_db</span>(
        device: &amp;<span class="hljs-type">str</span>,
        channel: &amp;ChannelType,
        db_path: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">str</span>&gt;,
        decoder: <span class="hljs-type">Option</span>&lt;D&gt;,
        output: W,
    ) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-keyword">Self</span>&gt; {
        <span class="hljs-comment">// DB-backed channel lookup</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">ChannelType</span>::Db { nid, sid, tsid, manual_sheet } = channel {
            <span class="hljs-comment">// Database lookup and channel configuration</span>
            <span class="hljs-comment">// ...</span>
        }
        <span class="hljs-comment">// Fallback to original tuning logic</span>
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<h3 id="25-プラットフォーム差異の処理">2.5 プラットフォーム差異の処理</h3>
<p><strong>AutoScan計画</strong>: TS解析が必要（実HW依存）
<strong>Proxy計画</strong>: クロスプラットフォーム対応</p>
<p><strong>統合案</strong>:</p>
<h4 id="251-feature-gated-ts解析">2.5.1 Feature-gated TS解析</h4>
<pre><code class="language-toml"><span class="hljs-comment"># recisdb-rs/Cargo.toml</span>
<span class="hljs-section">[features]</span>
<span class="hljs-attr">default</span> = [<span class="hljs-string">&quot;bg-runtime&quot;</span>, <span class="hljs-string">&quot;prioritized_card_reader&quot;</span>]
<span class="hljs-attr">ts-analyzer</span> = [<span class="hljs-string">&quot;bitstream-io&quot;</span>]  <span class="hljs-comment"># TS解析モード</span>
<span class="hljs-attr">database</span> = [<span class="hljs-string">&quot;rusqlite&quot;</span>, <span class="hljs-string">&quot;serde&quot;</span>, <span class="hljs-string">&quot;prettytable-rs&quot;</span>]  <span class="hljs-comment"># データベースモード</span>
</code></pre>
<h4 id="252-プラットフォーム別実装">2.5.2 プラットフォーム別実装</h4>
<pre><code class="language-rust"><span class="hljs-comment">// recisdb-rs/src/tuner/mod.rs</span>
<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Tuner</span> {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">open</span>(path: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-keyword">Self</span>, TunerError&gt; {
        <span class="hljs-meta">#[cfg(target_os = <span class="hljs-string">&quot;linux&quot;</span>)]</span>
        {
            <span class="hljs-keyword">if</span> path.<span class="hljs-title function_ invoke__">contains</span>(<span class="hljs-string">&quot;/dev/dvb/&quot;</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">DvbV5</span>(dvbv5::Tuner::<span class="hljs-title function_ invoke__">new</span>(path)?));
            }
            <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">Character</span>(character_device::Tuner::<span class="hljs-title function_ invoke__">new</span>(path)?));
        }
        <span class="hljs-meta">#[cfg(target_os = <span class="hljs-string">&quot;windows&quot;</span>)]</span>
        {
            <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">BonDriver</span>(windows::Tuner::<span class="hljs-title function_ invoke__">new</span>(path)?));
        }
    }
}
</code></pre>
<hr>
<h2 id="3-モジュール詳細設計">3. モジュール詳細設計</h2>
<h3 id="31-データベースモジュール-recisdb-rssrcdatabase">3.1 データベースモジュール (recisdb-rs/src/database/)</h3>
<p><strong>DBスキーマ</strong> (AutoScan計画から継承):</p>
<pre><code class="language-sql"><span class="hljs-comment">-- BonDriver管理</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> bon_drivers (
    id <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTOINCREMENT,
    dll_path TEXT <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    driver_name TEXT,
    version TEXT,
    <span class="hljs-comment">-- スキャン設定（チューナーごと）</span>
    auto_scan_enabled <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>,     <span class="hljs-comment">-- 自動スキャン有効/無効</span>
    scan_interval_hours <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">24</span>,  <span class="hljs-comment">-- スキャン間隔（時間、0=無効）</span>
    scan_priority <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>,         <span class="hljs-comment">-- スキャン優先度（高い順に実行）</span>
    last_scan <span class="hljs-type">INTEGER</span>,                       <span class="hljs-comment">-- 最終スキャン時刻</span>
    next_scan_at <span class="hljs-type">INTEGER</span>,                    <span class="hljs-comment">-- 次回スキャン予定時刻</span>
    <span class="hljs-comment">-- パッシブスキャン設定</span>
    passive_scan_enabled <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>,  <span class="hljs-comment">-- 配信中リアルタイム更新有効/無効</span>
    <span class="hljs-comment">-- メタデータ</span>
    created_at <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">DEFAULT</span> (strftime(<span class="hljs-string">&#x27;%s&#x27;</span>, <span class="hljs-string">&#x27;now&#x27;</span>)),
    updated_at <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">DEFAULT</span> (strftime(<span class="hljs-string">&#x27;%s&#x27;</span>, <span class="hljs-string">&#x27;now&#x27;</span>))
);

<span class="hljs-comment">-- チャンネル情報</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> channels (
    id <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTOINCREMENT,
    bon_driver_id <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    <span class="hljs-comment">-- 一意識別キー (NID-SID-TSID-manual_sheet)</span>
    nid <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,                <span class="hljs-comment">-- Network ID (SDTから取得)</span>
    sid <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,                <span class="hljs-comment">-- Service ID</span>
    tsid <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,               <span class="hljs-comment">-- Transport Stream ID</span>
    manual_sheet <span class="hljs-type">INTEGER</span>,                <span class="hljs-comment">-- ユーザー定義枝番 (NULL=標準)</span>
    <span class="hljs-comment">-- チャンネル情報</span>
    raw_name TEXT,                       <span class="hljs-comment">-- 生のサービス名 (ARIB文字列)</span>
    channel_name TEXT,                   <span class="hljs-comment">-- 正規化されたチャンネル名</span>
    physical_ch <span class="hljs-type">INTEGER</span>,                 <span class="hljs-comment">-- 物理チャンネル番号 (NITから取得)</span>
    remote_control_key <span class="hljs-type">INTEGER</span>,          <span class="hljs-comment">-- リモコンキーID (NITから取得)</span>
    service_type <span class="hljs-type">INTEGER</span>,                <span class="hljs-comment">-- サービス種別 (0x01=TV, 0x02=Radio, etc.)</span>
    network_name TEXT,                   <span class="hljs-comment">-- ネットワーク名 (NITから取得)</span>
    <span class="hljs-comment">-- BonDriver固有情報</span>
    bon_space <span class="hljs-type">INTEGER</span>,                   <span class="hljs-comment">-- BonDriverのSpace番号</span>
    bon_channel <span class="hljs-type">INTEGER</span>,                 <span class="hljs-comment">-- BonDriverのChannel番号</span>
    <span class="hljs-comment">-- 状態管理</span>
    is_enabled <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>,        <span class="hljs-comment">-- 有効/無効フラグ</span>
    scan_time <span class="hljs-type">INTEGER</span>,                   <span class="hljs-comment">-- 最終スキャン時刻</span>
    last_seen <span class="hljs-type">INTEGER</span>,                   <span class="hljs-comment">-- 最終検出時刻 (自動更新用)</span>
    failure_count <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>,     <span class="hljs-comment">-- 連続チューニング失敗回数</span>
    <span class="hljs-comment">-- 選択優先度</span>
    priority <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>,          <span class="hljs-comment">-- チャンネル選択優先度 (論理指定時に使用)</span>
    <span class="hljs-comment">-- メタデータ</span>
    created_at <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">DEFAULT</span> (strftime(<span class="hljs-string">&#x27;%s&#x27;</span>, <span class="hljs-string">&#x27;now&#x27;</span>)),
    updated_at <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">DEFAULT</span> (strftime(<span class="hljs-string">&#x27;%s&#x27;</span>, <span class="hljs-string">&#x27;now&#x27;</span>)),
    <span class="hljs-keyword">UNIQUE</span>(bon_driver_id, nid, sid, tsid, manual_sheet),
    <span class="hljs-keyword">FOREIGN</span> KEY(bon_driver_id) <span class="hljs-keyword">REFERENCES</span> bon_drivers(id) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE
);

<span class="hljs-comment">-- スキャン履歴</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> scan_history (
    id <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTOINCREMENT,
    bon_driver_id <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    scan_time <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">DEFAULT</span> (strftime(<span class="hljs-string">&#x27;%s&#x27;</span>, <span class="hljs-string">&#x27;now&#x27;</span>)),
    channel_count <span class="hljs-type">INTEGER</span>,
    success <span class="hljs-type">INTEGER</span>,
    error_message TEXT,
    <span class="hljs-keyword">FOREIGN</span> KEY(bon_driver_id) <span class="hljs-keyword">REFERENCES</span> bon_drivers(id) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE
);

<span class="hljs-comment">-- インデックス</span>
<span class="hljs-keyword">CREATE</span> INDEX idx_channels_bon_driver <span class="hljs-keyword">ON</span> channels(bon_driver_id);
<span class="hljs-keyword">CREATE</span> INDEX idx_channels_nid_sid_tsid <span class="hljs-keyword">ON</span> channels(nid, sid, tsid);
<span class="hljs-keyword">CREATE</span> INDEX idx_channels_enabled <span class="hljs-keyword">ON</span> channels(is_enabled);
<span class="hljs-keyword">CREATE</span> INDEX idx_scan_history_bon_driver <span class="hljs-keyword">ON</span> scan_history(bon_driver_id);
</code></pre>
<p><strong>主要機能</strong>:</p>
<ul>
<li><code>mod.rs</code> - データベース接続管理</li>
<li><code>models.rs</code> - データモデル定義</li>
<li><code>bon_driver.rs</code> - BonDriver CRUD操作</li>
<li><code>channel.rs</code> - チャンネル CRUD操作</li>
<li><code>scan_history.rs</code> - スキャン履歴管理</li>
</ul>
<h3 id="32-ts解析モジュール-recisdb-rssrcts_analyzer">3.2 TS解析モジュール (recisdb-rs/src/ts_analyzer/)</h3>
<p><strong>主要機能</strong>:</p>
<ul>
<li>PATパケット解析（Program Association Table）- TSID, SID一覧取得</li>
<li>PMTパケット解析（Program Map Table）- サービス種別検出</li>
<li><strong>SDTパケット解析（Service Description Table）- NID, サービス名取得</strong></li>
<li><strong>NITパケット解析（Network Information Table）- ネットワーク名、物理チャンネル情報取得</strong></li>
<li>サービス種別検出（TV/Radio/Data）</li>
</ul>
<p><strong>ARIB-STD-B10 テーブル構造</strong>:</p>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│  PSI/SI Tables for Channel Identification                   │
├─────────────────────────────────────────────────────────────┤
│  PAT (PID=0x0000)  → TSID, PMT PID一覧                      │
│  PMT (可変PID)      → ストリーム構成、サービス種別           │
│  SDT (PID=0x0011)  → NID, SID, サービス名、サービス種別      │
│  NIT (PID=0x0010)  → ネットワーク名、TS一覧、物理チャンネル  │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>変換ロジック</strong>:</p>
<pre><code class="language-rust"><span class="hljs-comment">// TSパケット → PAT/SDT/NIT → ChannelInfo</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TsAnalyzer</span> {
    pat: <span class="hljs-type">Option</span>&lt;PAT&gt;,
    sdt: <span class="hljs-type">Option</span>&lt;SDT&gt;,
    nit: <span class="hljs-type">Option</span>&lt;NIT&gt;,
    pmt_map: HashMap&lt;<span class="hljs-type">u16</span>, PMT&gt;,  <span class="hljs-comment">// program_number -&gt; PMT</span>
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">TsAnalyzer</span> {
    <span class="hljs-comment">/// TSパケットを投入し、テーブルを蓄積</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">feed</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, packet: &amp;[<span class="hljs-type">u8</span>; <span class="hljs-number">188</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), TsError&gt; {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">pid</span> = <span class="hljs-title function_ invoke__">get_pid</span>(packet);
        <span class="hljs-keyword">match</span> pid {
            <span class="hljs-number">0x0000</span> =&gt; <span class="hljs-keyword">self</span>.pat = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-title function_ invoke__">parse_pat</span>(packet)?),
            <span class="hljs-number">0x0010</span> =&gt; <span class="hljs-keyword">self</span>.nit = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-title function_ invoke__">parse_nit</span>(packet)?),
            <span class="hljs-number">0x0011</span> =&gt; <span class="hljs-keyword">self</span>.sdt = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-title function_ invoke__">parse_sdt</span>(packet)?),
            _ =&gt; {
                <span class="hljs-comment">// PMT PIDの場合</span>
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(pat) = &amp;<span class="hljs-keyword">self</span>.pat {
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(pn) = pat.<span class="hljs-title function_ invoke__">get_program_number_for_pid</span>(pid) {
                        <span class="hljs-keyword">self</span>.pmt_map.<span class="hljs-title function_ invoke__">insert</span>(pn, <span class="hljs-title function_ invoke__">parse_pmt</span>(packet)?);
                    }
                }
            }
        }
        <span class="hljs-title function_ invoke__">Ok</span>(())
    }

    <span class="hljs-comment">/// 解析完了判定（PAT+SDT+NITが揃ったか）</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_complete</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> {
        <span class="hljs-keyword">self</span>.pat.<span class="hljs-title function_ invoke__">is_some</span>() &amp;&amp; <span class="hljs-keyword">self</span>.sdt.<span class="hljs-title function_ invoke__">is_some</span>() &amp;&amp; <span class="hljs-keyword">self</span>.nit.<span class="hljs-title function_ invoke__">is_some</span>()
    }

    <span class="hljs-comment">/// チャンネル情報を抽出</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">extract_channels</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;ChannelInfo&gt; {
        <span class="hljs-keyword">let</span> (sdt, nit) = <span class="hljs-title function_ invoke__">match</span> (&amp;<span class="hljs-keyword">self</span>.sdt, &amp;<span class="hljs-keyword">self</span>.nit) {
            (<span class="hljs-title function_ invoke__">Some</span>(sdt), <span class="hljs-title function_ invoke__">Some</span>(nit)) =&gt; (sdt, nit),
            _ =&gt; <span class="hljs-keyword">return</span> Vec::<span class="hljs-title function_ invoke__">new</span>(),  <span class="hljs-comment">// 未完了なら空リスト</span>
        };

        sdt.services.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|service| {
            ChannelInfo {
                nid: sdt.original_network_id,  <span class="hljs-comment">// SDTから取得</span>
                sid: service.service_id,
                tsid: sdt.transport_stream_id,
                manual_sheet: <span class="hljs-literal">None</span>,
                raw_name: service.service_name.<span class="hljs-title function_ invoke__">clone</span>(),
                channel_name: <span class="hljs-title function_ invoke__">normalize_channel_name</span>(&amp;service.service_name),
                physical_ch: nit.<span class="hljs-title function_ invoke__">get_physical_channel</span>(sdt.transport_stream_id),
                remote_control_key: nit.<span class="hljs-title function_ invoke__">get_remote_control_key</span>(service.service_id),
                service_type: <span class="hljs-title function_ invoke__">Some</span>(service.service_type),
                network_name: <span class="hljs-title function_ invoke__">Some</span>(nit.network_name.<span class="hljs-title function_ invoke__">clone</span>()),
                bon_space: <span class="hljs-literal">None</span>,     <span class="hljs-comment">// スキャン時に設定</span>
                bon_channel: <span class="hljs-literal">None</span>,   <span class="hljs-comment">// スキャン時に設定</span>
            }
        }).<span class="hljs-title function_ invoke__">collect</span>()
    }
}
</code></pre>
<p><strong>NID-SID-TSIDの取得元</strong>:</p>
<table>
<thead>
<tr>
<th>フィールド</th>
<th>取得元テーブル</th>
<th>備考</th>
</tr>
</thead>
<tbody>
<tr>
<td>NID</td>
<td>SDT (original_network_id)</td>
<td>放送事業者識別</td>
</tr>
<tr>
<td>SID</td>
<td>SDT/PAT (service_id/program_number)</td>
<td>サービス識別</td>
</tr>
<tr>
<td>TSID</td>
<td>PAT/SDT (transport_stream_id)</td>
<td>トランスポートストリーム識別</td>
</tr>
</tbody>
</table>
<h3 id="33-チャンネルグループ化ロジック">3.3 チャンネルグループ化ロジック</h3>
<p><strong>一意識別キー</strong>: <code>(NID, SID, TSID, manual_sheet)</code></p>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│  チャンネル識別の階層構造                                    │
├─────────────────────────────────────────────────────────────┤
│  NID (Network ID)                                           │
│    └── TSID (Transport Stream ID)                           │
│          └── SID (Service ID)                               │
│                └── manual_sheet (ユーザー定義枝番)           │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>グループ化ルール</strong>:</p>
<table>
<thead>
<tr>
<th>ケース</th>
<th>判定条件</th>
<th>動作</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一サービス</td>
<td>NID+SID+TSID一致</td>
<td>既存レコードを更新</td>
</tr>
<tr>
<td>異なるBonDriver</td>
<td>同一NID+SID+TSID、異なるbon_driver_id</td>
<td>各BonDriverで個別レコード作成</td>
</tr>
<tr>
<td>マニュアル分割</td>
<td>manual_sheet指定</td>
<td>同一NID+SID+TSIDでも別レコード</td>
</tr>
<tr>
<td>サービス消失</td>
<td>スキャン時に検出されない</td>
<td>is_enabled=0 に更新（削除しない）</td>
</tr>
</tbody>
</table>
<p><strong>マニュアル枝番の用途</strong>:</p>
<pre><code class="language-rust"><span class="hljs-comment">/// manual_sheet は以下の用途で使用:</span>
<span class="hljs-comment">/// - 同一サービスを複数のプリセットに分けたい場合</span>
<span class="hljs-comment">/// - 時間帯別にチャンネルをグループ化したい場合</span>
<span class="hljs-comment">/// - ユーザーが明示的に別管理したい場合</span>

<span class="hljs-comment">// 例: BS朝日を複数プリセットで管理</span>
<span class="hljs-comment">// NID=4, SID=151, TSID=16400, manual_sheet=None  → 標準</span>
<span class="hljs-comment">// NID=4, SID=151, TSID=16400, manual_sheet=Some(1) → お気に入り1</span>
<span class="hljs-comment">// NID=4, SID=151, TSID=16400, manual_sheet=Some(2) → お気に入り2</span>
</code></pre>
<p><strong>DBクエリ例</strong>:</p>
<pre><code class="language-sql"><span class="hljs-comment">-- 同一サービスの検索（manual_sheetを無視）</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> channels
<span class="hljs-keyword">WHERE</span> nid <span class="hljs-operator">=</span> ? <span class="hljs-keyword">AND</span> sid <span class="hljs-operator">=</span> ? <span class="hljs-keyword">AND</span> tsid <span class="hljs-operator">=</span> ?
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> manual_sheet NULLS <span class="hljs-keyword">FIRST</span>;

<span class="hljs-comment">-- 完全一致検索</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> channels
<span class="hljs-keyword">WHERE</span> nid <span class="hljs-operator">=</span> ? <span class="hljs-keyword">AND</span> sid <span class="hljs-operator">=</span> ? <span class="hljs-keyword">AND</span> tsid <span class="hljs-operator">=</span> ?
  <span class="hljs-keyword">AND</span> (manual_sheet <span class="hljs-operator">=</span> ? <span class="hljs-keyword">OR</span> (manual_sheet <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">AND</span> ? <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>));

<span class="hljs-comment">-- BonDriver別グループ化</span>
<span class="hljs-keyword">SELECT</span> bon_drivers.dll_path, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> channel_count
<span class="hljs-keyword">FROM</span> channels
<span class="hljs-keyword">JOIN</span> bon_drivers <span class="hljs-keyword">ON</span> channels.bon_driver_id <span class="hljs-operator">=</span> bon_drivers.id
<span class="hljs-keyword">WHERE</span> channels.is_enabled <span class="hljs-operator">=</span> <span class="hljs-number">1</span>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> bon_drivers.id;
</code></pre>
<h3 id="34-自動更新メカニズム">3.4 自動更新メカニズム</h3>
<p><strong>更新戦略</strong>:</p>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│  スキャン → 差分検出 → マージ                                │
├─────────────────────────────────────────────────────────────┤
│  1. 新規スキャン実行                                         │
│  2. 既存DBと比較 (NID+SID+TSID+bon_driver_id で照合)         │
│  3. 差分に応じた処理:                                        │
│     - 新規: INSERT                                          │
│     - 更新: UPDATE (channel_name, service_type等)           │
│     - 消失: is_enabled = 0 (ソフトデリート)                  │
│     - 復活: is_enabled = 1                                  │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>実装</strong>:</p>
<pre><code class="language-rust"><span class="hljs-comment">// recisdb-rs/src/database/channel.rs</span>
<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Database</span> {
    <span class="hljs-comment">/// スキャン結果をDBにマージ</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge_scan_results</span>(
        &amp;<span class="hljs-keyword">self</span>,
        bon_driver_id: <span class="hljs-type">i64</span>,
        scanned_channels: &amp;[ChannelInfo],
    ) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;MergeResult&gt; {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">tx</span> = <span class="hljs-keyword">self</span>.conn.<span class="hljs-title function_ invoke__">transaction</span>()?;
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">result</span> = MergeResult::<span class="hljs-title function_ invoke__">default</span>();

        <span class="hljs-comment">// 既存チャンネルを取得</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">existing</span> = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">get_channels_by_bon_driver</span>(bon_driver_id)?;
        <span class="hljs-keyword">let</span> <span class="hljs-variable">existing_keys</span>: HashSet&lt;_&gt; = existing.<span class="hljs-title function_ invoke__">iter</span>()
            .<span class="hljs-title function_ invoke__">map</span>(|c| (c.nid, c.sid, c.tsid))
            .<span class="hljs-title function_ invoke__">collect</span>();

        <span class="hljs-comment">// スキャン結果を処理</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">scanned_keys</span>: HashSet&lt;_&gt; = scanned_channels.<span class="hljs-title function_ invoke__">iter</span>()
            .<span class="hljs-title function_ invoke__">map</span>(|c| (c.nid, c.sid, c.tsid))
            .<span class="hljs-title function_ invoke__">collect</span>();

        <span class="hljs-keyword">for</span> <span class="hljs-variable">channel</span> <span class="hljs-keyword">in</span> scanned_channels {
            <span class="hljs-keyword">let</span> <span class="hljs-variable">key</span> = (channel.nid, channel.sid, channel.tsid);
            <span class="hljs-keyword">if</span> existing_keys.<span class="hljs-title function_ invoke__">contains</span>(&amp;key) {
                <span class="hljs-comment">// 更新</span>
                <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">update_channel</span>(bon_driver_id, channel)?;
                result.updated += <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 新規挿入</span>
                <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">insert_channel</span>(bon_driver_id, channel)?;
                result.inserted += <span class="hljs-number">1</span>;
            }
        }

        <span class="hljs-comment">// 消失したチャンネルを無効化</span>
        <span class="hljs-keyword">for</span> <span class="hljs-variable">existing_ch</span> <span class="hljs-keyword">in</span> &amp;existing {
            <span class="hljs-keyword">let</span> <span class="hljs-variable">key</span> = (existing_ch.nid, existing_ch.sid, existing_ch.tsid);
            <span class="hljs-keyword">if</span> !scanned_keys.<span class="hljs-title function_ invoke__">contains</span>(&amp;key) &amp;&amp; existing_ch.is_enabled {
                <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">disable_channel</span>(existing_ch.id)?;
                result.disabled += <span class="hljs-number">1</span>;
            }
        }

        tx.<span class="hljs-title function_ invoke__">commit</span>()?;
        <span class="hljs-title function_ invoke__">Ok</span>(result)
    }

    <span class="hljs-comment">/// 定期スキャン用: 最終スキャンから指定時間経過したBonDriverを取得</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_stale_bon_drivers</span>(&amp;<span class="hljs-keyword">self</span>, max_age_secs: <span class="hljs-type">i64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Vec</span>&lt;BonDriver&gt;&gt; {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">threshold</span> = chrono::Utc::<span class="hljs-title function_ invoke__">now</span>().<span class="hljs-title function_ invoke__">timestamp</span>() - max_age_secs;
        <span class="hljs-keyword">self</span>.conn.<span class="hljs-title function_ invoke__">prepare</span>(
            <span class="hljs-string">&quot;SELECT * FROM bon_drivers WHERE last_scan &lt; ? OR last_scan IS NULL&quot;</span>
        )?.<span class="hljs-title function_ invoke__">query_map</span>([threshold], |row| <span class="hljs-comment">/* ... */</span>)
    }
}

<span class="hljs-meta">#[derive(Default)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MergeResult</span> {
    <span class="hljs-keyword">pub</span> inserted: <span class="hljs-type">usize</span>,
    <span class="hljs-keyword">pub</span> updated: <span class="hljs-type">usize</span>,
    <span class="hljs-keyword">pub</span> disabled: <span class="hljs-type">usize</span>,
}
</code></pre>
<p><strong>自動更新トリガー</strong>:</p>
<table>
<thead>
<tr>
<th>トリガー</th>
<th>条件</th>
<th>動作</th>
</tr>
</thead>
<tbody>
<tr>
<td>起動時スキャン</td>
<td><code>--auto-scan</code> フラグ</td>
<td>起動時に全BonDriverをスキャン</td>
</tr>
<tr>
<td>定期スキャン</td>
<td><code>scan_interval</code> 設定</td>
<td>指定間隔で自動スキャン</td>
</tr>
<tr>
<td>手動スキャン</td>
<td><code>recisdb scan</code> コマンド</td>
<td>ユーザー明示実行</td>
</tr>
<tr>
<td>チューニング失敗時</td>
<td>signal_level &lt; threshold</td>
<td>該当チャンネルを再スキャン</td>
</tr>
</tbody>
</table>
<p><strong>設定ファイル拡張</strong>:</p>
<pre><code class="language-toml"><span class="hljs-comment"># ~/.config/recisdb/config.toml</span>
<span class="hljs-section">[scan]</span>
<span class="hljs-attr">auto_scan_on_startup</span> = <span class="hljs-literal">true</span>      <span class="hljs-comment"># 起動時自動スキャン</span>
<span class="hljs-attr">timeout_per_channel_secs</span> = <span class="hljs-number">5</span>     <span class="hljs-comment"># チャンネルあたりのスキャンタイムアウト</span>
<span class="hljs-attr">retry_on_failure</span> = <span class="hljs-number">3</span>             <span class="hljs-comment"># 失敗時リトライ回数</span>
<span class="hljs-attr">disable_after_failures</span> = <span class="hljs-number">5</span>       <span class="hljs-comment"># N回連続失敗でチャンネル無効化</span>
<span class="hljs-comment"># 注: scan_interval_hours はDB側 (bon_drivers.scan_interval_hours) で管理</span>
</code></pre>
<h3 id="35-パッシブスキャン配信中リアルタイム更新">3.5 パッシブスキャン（配信中リアルタイム更新）</h3>
<p><strong>概要</strong>: TS配信中は常にPAT/SDT/NITパケットが流れているため、これを監視することでチャンネル情報をリアルタイム更新できる。</p>
<pre><code>┌─────────────────────────────────────────────────────────────────────┐
│  パッシブスキャン アーキテクチャ                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐             │
│  │  TSパケット  │───▶│  Demuxer    │───▶│  クライアント │             │
│  │  (188bytes) │    │             │    │  (配信)      │             │
│  └─────────────┘    └──────┬──────┘    └─────────────┘             │
│                            │                                        │
│                            │ PAT/SDT/NIT パケット                   │
│                            ▼                                        │
│                     ┌─────────────┐                                 │
│                     │  Passive    │                                 │
│                     │  Analyzer   │                                 │
│                     └──────┬──────┘                                 │
│                            │                                        │
│                            ▼                                        │
│                     ┌─────────────┐                                 │
│                     │  Database   │                                 │
│                     │  (upsert)   │                                 │
│                     └─────────────┘                                 │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>実装</strong>:</p>
<pre><code class="language-rust"><span class="hljs-comment">// recisdb-proxy/src/tuner/passive_scanner.rs</span>

<span class="hljs-keyword">use</span> tokio::sync::mpsc;
<span class="hljs-keyword">use</span> crate::ts_analyzer::TsAnalyzer;
<span class="hljs-keyword">use</span> crate::database::Database;

<span class="hljs-comment">/// パッシブスキャナー: 配信中のTSからチャンネル情報を抽出・更新</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PassiveScanner</span> {
    analyzer: TsAnalyzer,
    db: Arc&lt;Database&gt;,
    bon_driver_id: <span class="hljs-type">i64</span>,
    current_channel: <span class="hljs-type">Option</span>&lt;(<span class="hljs-type">u32</span>, <span class="hljs-type">u32</span>)&gt;,  <span class="hljs-comment">// (space, channel)</span>
    last_update: Instant,
    update_interval: Duration,  <span class="hljs-comment">// 更新間隔（デフォルト: 30秒）</span>
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">PassiveScanner</span> {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(db: Arc&lt;Database&gt;, bon_driver_id: <span class="hljs-type">i64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">Self</span> {
            analyzer: TsAnalyzer::<span class="hljs-title function_ invoke__">new</span>(),
            db,
            bon_driver_id,
            current_channel: <span class="hljs-literal">None</span>,
            last_update: Instant::<span class="hljs-title function_ invoke__">now</span>(),
            update_interval: Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">30</span>),
        }
    }

    <span class="hljs-comment">/// TSパケットを投入（配信パイプラインから呼び出し）</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">feed</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, packet: &amp;[<span class="hljs-type">u8</span>; <span class="hljs-number">188</span>]) {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">pid</span> = <span class="hljs-title function_ invoke__">get_pid</span>(packet);

        <span class="hljs-comment">// PSI/SIパケットのみ処理</span>
        <span class="hljs-keyword">match</span> pid {
            <span class="hljs-number">0x0000</span> | <span class="hljs-number">0x0010</span> | <span class="hljs-number">0x0011</span> =&gt; {
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Err</span>(e) = <span class="hljs-keyword">self</span>.analyzer.<span class="hljs-title function_ invoke__">feed</span>(packet) {
                    debug!(<span class="hljs-string">&quot;Passive scan feed error: {}&quot;</span>, e);
                }
            }
            _ =&gt; <span class="hljs-keyword">return</span>,
        }

        <span class="hljs-comment">// 定期的にDB更新</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.last_update.<span class="hljs-title function_ invoke__">elapsed</span>() &gt;= <span class="hljs-keyword">self</span>.update_interval {
            <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">try_update_db</span>();
        }
    }

    <span class="hljs-comment">/// 解析結果をDBに反映</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">try_update_db</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">if</span> !<span class="hljs-keyword">self</span>.analyzer.<span class="hljs-title function_ invoke__">is_complete</span>() {
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">let</span> <span class="hljs-variable">channels</span> = <span class="hljs-keyword">self</span>.analyzer.<span class="hljs-title function_ invoke__">extract_channels</span>();
        <span class="hljs-keyword">if</span> channels.<span class="hljs-title function_ invoke__">is_empty</span>() {
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// BonDriver固有情報を追加</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">channels</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = channels.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">map</span>(|<span class="hljs-keyword">mut</span> ch| {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>((space, channel)) = <span class="hljs-keyword">self</span>.current_channel {
                ch.bon_space = <span class="hljs-title function_ invoke__">Some</span>(space);
                ch.bon_channel = <span class="hljs-title function_ invoke__">Some</span>(channel);
            }
            ch
        }).<span class="hljs-title function_ invoke__">collect</span>();

        <span class="hljs-comment">// 差分更新（軽量版：last_seenのみ更新 or 変更があればフル更新）</span>
        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.db.<span class="hljs-title function_ invoke__">passive_update_channels</span>(<span class="hljs-keyword">self</span>.bon_driver_id, &amp;channels) {
            <span class="hljs-title function_ invoke__">Ok</span>(updated) =&gt; {
                <span class="hljs-keyword">if</span> updated &gt; <span class="hljs-number">0</span> {
                    info!(<span class="hljs-string">&quot;Passive scan: updated {} channels&quot;</span>, updated);
                }
            }
            <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; {
                warn!(<span class="hljs-string">&quot;Passive scan DB update failed: {}&quot;</span>, e);
            }
        }

        <span class="hljs-keyword">self</span>.last_update = Instant::<span class="hljs-title function_ invoke__">now</span>();
        <span class="hljs-keyword">self</span>.analyzer.<span class="hljs-title function_ invoke__">reset</span>();  <span class="hljs-comment">// 次のサイクル用にリセット</span>
    }

    <span class="hljs-comment">/// チャンネル変更時に呼び出し</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">on_channel_changed</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, space: <span class="hljs-type">u32</span>, channel: <span class="hljs-type">u32</span>) {
        <span class="hljs-keyword">self</span>.current_channel = <span class="hljs-title function_ invoke__">Some</span>((space, channel));
        <span class="hljs-keyword">self</span>.analyzer.<span class="hljs-title function_ invoke__">reset</span>();
    }
}
</code></pre>
<p><strong>DB操作（軽量更新）</strong>:</p>
<pre><code class="language-rust"><span class="hljs-comment">// recisdb-rs/src/database/channel.rs</span>
<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Database</span> {
    <span class="hljs-comment">/// パッシブスキャン用: last_seen更新 + 変更検出時のみフル更新</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">passive_update_channels</span>(
        &amp;<span class="hljs-keyword">self</span>,
        bon_driver_id: <span class="hljs-type">i64</span>,
        channels: &amp;[ChannelInfo],
    ) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">usize</span>&gt; {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">now</span> = chrono::Utc::<span class="hljs-title function_ invoke__">now</span>().<span class="hljs-title function_ invoke__">timestamp</span>();
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">updated</span> = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> <span class="hljs-variable">channel</span> <span class="hljs-keyword">in</span> channels {
            <span class="hljs-keyword">let</span> <span class="hljs-variable">existing</span> = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">get_channel_by_key</span>(
                bon_driver_id,
                channel.nid,
                channel.sid,
                channel.tsid,
            )?;

            <span class="hljs-keyword">match</span> existing {
                <span class="hljs-title function_ invoke__">Some</span>(existing) =&gt; {
                    <span class="hljs-comment">// last_seen を更新</span>
                    <span class="hljs-keyword">self</span>.conn.<span class="hljs-title function_ invoke__">execute</span>(
                        <span class="hljs-string">&quot;UPDATE channels SET last_seen = ?, failure_count = 0 WHERE id = ?&quot;</span>,
                        [now, existing.id],
                    )?;

                    <span class="hljs-comment">// チャンネル名やservice_typeに変更があればフル更新</span>
                    <span class="hljs-keyword">if</span> existing.channel_name != channel.channel_name
                        || existing.service_type != channel.service_type
                    {
                        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">update_channel</span>(bon_driver_id, channel)?;
                        updated += <span class="hljs-number">1</span>;
                    }
                }
                <span class="hljs-literal">None</span> =&gt; {
                    <span class="hljs-comment">// 新規チャンネル発見</span>
                    <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">insert_channel</span>(bon_driver_id, channel)?;
                    updated += <span class="hljs-number">1</span>;
                    info!(<span class="hljs-string">&quot;Passive scan: new channel discovered: NID={}, SID={}, TSID={}&quot;</span>,
                        channel.nid, channel.sid, channel.tsid);
                }
            }
        }

        <span class="hljs-title function_ invoke__">Ok</span>(updated)
    }
}
</code></pre>
<p><strong>SharedTunerへの統合</strong>:</p>
<pre><code class="language-rust"><span class="hljs-comment">// recisdb-proxy/src/tuner/shared.rs</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SharedTuner</span> {
    <span class="hljs-comment">// ... 既存フィールド</span>
    passive_scanner: <span class="hljs-type">Option</span>&lt;Mutex&lt;PassiveScanner&gt;&gt;,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">SharedTuner</span> {
    <span class="hljs-comment">/// TSデータを配信（パッシブスキャン付き）</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">broadcast_with_passive_scan</span>(&amp;<span class="hljs-keyword">self</span>, packet: &amp;[<span class="hljs-type">u8</span>; <span class="hljs-number">188</span>]) {
        <span class="hljs-comment">// クライアントへ配信</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = <span class="hljs-keyword">self</span>.tx.<span class="hljs-title function_ invoke__">send</span>(packet.<span class="hljs-title function_ invoke__">to_vec</span>());

        <span class="hljs-comment">// パッシブスキャン（有効な場合のみ）</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(scanner) = &amp;<span class="hljs-keyword">self</span>.passive_scanner {
            scanner.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">feed</span>(packet);
        }
    }
}
</code></pre>
<h3 id="36-チューナーごとのスキャンスケジューリング">3.6 チューナーごとのスキャンスケジューリング</h3>
<p><strong>DB設定による個別制御</strong>:</p>
<pre><code class="language-sql"><span class="hljs-comment">-- チューナーごとのスキャン設定例</span>
<span class="hljs-keyword">UPDATE</span> bon_drivers <span class="hljs-keyword">SET</span>
    auto_scan_enabled <span class="hljs-operator">=</span> <span class="hljs-number">1</span>,       <span class="hljs-comment">-- 自動スキャン有効</span>
    scan_interval_hours <span class="hljs-operator">=</span> <span class="hljs-number">12</span>,    <span class="hljs-comment">-- 12時間ごと</span>
    scan_priority <span class="hljs-operator">=</span> <span class="hljs-number">10</span>,          <span class="hljs-comment">-- 高優先度</span>
    passive_scan_enabled <span class="hljs-operator">=</span> <span class="hljs-number">1</span>     <span class="hljs-comment">-- パッシブスキャン有効</span>
<span class="hljs-keyword">WHERE</span> dll_path <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;BonDriver_PT3-S.dll&#x27;</span>;

<span class="hljs-comment">-- 地デジチューナーは週1回スキャン</span>
<span class="hljs-keyword">UPDATE</span> bon_drivers <span class="hljs-keyword">SET</span>
    auto_scan_enabled <span class="hljs-operator">=</span> <span class="hljs-number">1</span>,
    scan_interval_hours <span class="hljs-operator">=</span> <span class="hljs-number">168</span>,   <span class="hljs-comment">-- 168時間 = 1週間</span>
    scan_priority <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,           <span class="hljs-comment">-- 低優先度</span>
    passive_scan_enabled <span class="hljs-operator">=</span> <span class="hljs-number">1</span>
<span class="hljs-keyword">WHERE</span> dll_path <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;BonDriver_PT3-T.dll&#x27;</span>;

<span class="hljs-comment">-- 特定チューナーは手動スキャンのみ</span>
<span class="hljs-keyword">UPDATE</span> bon_drivers <span class="hljs-keyword">SET</span>
    auto_scan_enabled <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,       <span class="hljs-comment">-- 自動スキャン無効</span>
    passive_scan_enabled <span class="hljs-operator">=</span> <span class="hljs-number">0</span>     <span class="hljs-comment">-- パッシブスキャンも無効</span>
<span class="hljs-keyword">WHERE</span> dll_path <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;BonDriver_OLD.dll&#x27;</span>;
</code></pre>
<p><strong>スケジューラー実装</strong>:</p>
<pre><code class="language-rust"><span class="hljs-comment">// recisdb-proxy/src/scheduler/scan_scheduler.rs</span>

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ScanScheduler</span> {
    db: Arc&lt;Database&gt;,
    tuner_pool: Arc&lt;TunerPool&gt;,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">ScanScheduler</span> {
    <span class="hljs-comment">/// スケジューラーのメインループ</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run</span>(&amp;<span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">interval</span> = tokio::time::<span class="hljs-title function_ invoke__">interval</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">60</span>));

        <span class="hljs-keyword">loop</span> {
            interval.<span class="hljs-title function_ invoke__">tick</span>().<span class="hljs-keyword">await</span>;

            <span class="hljs-comment">// スキャン対象のBonDriverを取得</span>
            <span class="hljs-keyword">let</span> <span class="hljs-variable">due_drivers</span> = <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.db.<span class="hljs-title function_ invoke__">get_due_bon_drivers</span>() {
                <span class="hljs-title function_ invoke__">Ok</span>(drivers) =&gt; drivers,
                <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; {
                    error!(<span class="hljs-string">&quot;Failed to get due bon_drivers: {}&quot;</span>, e);
                    <span class="hljs-keyword">continue</span>;
                }
            };

            <span class="hljs-comment">// 優先度順にソート</span>
            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">due_drivers</span> = due_drivers;
            due_drivers.<span class="hljs-title function_ invoke__">sort_by</span>(|a, b| b.scan_priority.<span class="hljs-title function_ invoke__">cmp</span>(&amp;a.scan_priority));

            <span class="hljs-keyword">for</span> <span class="hljs-variable">driver</span> <span class="hljs-keyword">in</span> due_drivers {
                info!(<span class="hljs-string">&quot;Starting scheduled scan for: {}&quot;</span>, driver.dll_path);

                <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">scan_bon_driver</span>(&amp;driver).<span class="hljs-keyword">await</span> {
                    <span class="hljs-title function_ invoke__">Ok</span>(result) =&gt; {
                        <span class="hljs-comment">// 次回スキャン時刻を更新</span>
                        <span class="hljs-keyword">let</span> <span class="hljs-variable">next_scan</span> = chrono::Utc::<span class="hljs-title function_ invoke__">now</span>().<span class="hljs-title function_ invoke__">timestamp</span>()
                            + (driver.scan_interval_hours <span class="hljs-keyword">as</span> <span class="hljs-type">i64</span> * <span class="hljs-number">3600</span>);
                        <span class="hljs-keyword">self</span>.db.<span class="hljs-title function_ invoke__">update_next_scan</span>(driver.id, next_scan).<span class="hljs-title function_ invoke__">ok</span>();

                        info!(<span class="hljs-string">&quot;Scheduled scan complete: {} (inserted={}, updated={}, disabled={})&quot;</span>,
                            driver.dll_path,
                            result.merge_result.inserted,
                            result.merge_result.updated,
                            result.merge_result.disabled);
                    }
                    <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; {
                        warn!(<span class="hljs-string">&quot;Scheduled scan failed for {}: {}&quot;</span>, driver.dll_path, e);
                    }
                }
            }
        }
    }
}

<span class="hljs-comment">// Database側</span>
<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Database</span> {
    <span class="hljs-comment">/// スキャン期限が来ているBonDriverを取得</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_due_bon_drivers</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Vec</span>&lt;BonDriver&gt;&gt; {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">now</span> = chrono::Utc::<span class="hljs-title function_ invoke__">now</span>().<span class="hljs-title function_ invoke__">timestamp</span>();
        <span class="hljs-keyword">self</span>.conn.<span class="hljs-title function_ invoke__">prepare</span>(
            <span class="hljs-string">&quot;SELECT * FROM bon_drivers
             WHERE auto_scan_enabled = 1
               AND scan_interval_hours &gt; 0
               AND (next_scan_at IS NULL OR next_scan_at &lt;= ?)
             ORDER BY scan_priority DESC, next_scan_at ASC&quot;</span>
        )?.<span class="hljs-title function_ invoke__">query_map</span>([now], |row| <span class="hljs-comment">/* ... */</span>)
    }

    <span class="hljs-comment">/// 次回スキャン時刻を更新</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">update_next_scan</span>(&amp;<span class="hljs-keyword">self</span>, bon_driver_id: <span class="hljs-type">i64</span>, next_scan_at: <span class="hljs-type">i64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt; {
        <span class="hljs-keyword">self</span>.conn.<span class="hljs-title function_ invoke__">execute</span>(
            <span class="hljs-string">&quot;UPDATE bon_drivers SET next_scan_at = ?, last_scan = strftime(&#x27;%s&#x27;, &#x27;now&#x27;)
             WHERE id = ?&quot;</span>,
            [next_scan_at, bon_driver_id],
        )?;
        <span class="hljs-title function_ invoke__">Ok</span>(())
    }
}
</code></pre>
<p><strong>CLIでのスキャン設定管理</strong>:</p>
<pre><code class="language-bash"><span class="hljs-comment"># スキャン設定の表示</span>
recisdb scan-config --device BonDriver_PT3-S.dll

<span class="hljs-comment"># スキャン間隔の変更</span>
recisdb scan-config --device BonDriver_PT3-S.dll --interval 12

<span class="hljs-comment"># 自動スキャンを無効化</span>
recisdb scan-config --device BonDriver_PT3-S.dll --auto-scan off

<span class="hljs-comment"># パッシブスキャンを無効化</span>
recisdb scan-config --device BonDriver_PT3-S.dll --passive-scan off

<span class="hljs-comment"># 優先度の変更</span>
recisdb scan-config --device BonDriver_PT3-S.dll --priority 10

<span class="hljs-comment"># 即時スキャン実行（スケジュール無視）</span>
recisdb scan --device BonDriver_PT3-S.dll --force
</code></pre>
<p><strong>コマンド定義の追加</strong>:</p>
<pre><code class="language-rust"><span class="hljs-comment">// recisdb-rs/src/context.rs に追加</span>
<span class="hljs-meta">#[clap(name = <span class="hljs-string">&quot;scan-config&quot;</span>)]</span>
ScanConfig {
    <span class="hljs-comment">/// BonDriver DLL path</span>
    <span class="hljs-meta">#[clap(short, long)]</span>
    device: <span class="hljs-type">String</span>,

    <span class="hljs-comment">/// Database file path</span>
    <span class="hljs-meta">#[clap(long)]</span>
    database: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,

    <span class="hljs-comment">/// Set scan interval in hours (0 = disable auto scan)</span>
    <span class="hljs-meta">#[clap(long)]</span>
    interval: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u32</span>&gt;,

    <span class="hljs-comment">/// Enable/disable auto scan (on/off)</span>
    <span class="hljs-meta">#[clap(long)]</span>
    auto_scan: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,

    <span class="hljs-comment">/// Enable/disable passive scan (on/off)</span>
    <span class="hljs-meta">#[clap(long)]</span>
    passive_scan: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,

    <span class="hljs-comment">/// Set scan priority (higher = scanned first)</span>
    <span class="hljs-meta">#[clap(long)]</span>
    priority: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt;,
}
</code></pre>
<h3 id="37-チャンネル選択ロジックと排他ロック">3.7 チャンネル選択ロジックと排他ロック</h3>
<h4 id="371-チャンネル選択モード">3.7.1 チャンネル選択モード</h4>
<p><strong>2種類のチャンネル指定方式</strong>:</p>
<pre><code>┌─────────────────────────────────────────────────────────────────────┐
│  チャンネル選択モード                                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  [Mode 1] 物理指定モード (Physical Mode)                            │
│    └── tuner_id + space + channel で直接指定                        │
│    └── DBの is_enabled フラグを無視                                 │
│    └── 排他ロック必須                                               │
│                                                                     │
│  [Mode 2] 論理指定モード (Logical Mode)                             │
│    └── NID + TSID (+ SID) で指定                                    │
│    └── DBから最適なチューナー・チャンネルを自動選択                  │
│    └── 優先度・空き状況に基づいて選択                               │
│    └── チャンネル共有可能                                           │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>選択モード判定</strong>:</p>
<pre><code class="language-rust"><span class="hljs-comment">// recisdb-protocol/src/types.rs</span>
<span class="hljs-meta">#[derive(Debug, Clone, Serialize, Deserialize)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ChannelSelector</span> {
    <span class="hljs-comment">/// 物理指定: DBの有効/無効を無視して直接選局</span>
    Physical {
        tuner_id: <span class="hljs-type">String</span>,      <span class="hljs-comment">// BonDriver識別子</span>
        space: <span class="hljs-type">u32</span>,            <span class="hljs-comment">// チューナー空間</span>
        channel: <span class="hljs-type">u32</span>,          <span class="hljs-comment">// 物理チャンネル番号</span>
    },

    <span class="hljs-comment">/// 論理指定: NID/TSIDでDB検索→最適チューナー選択</span>
    Logical {
        nid: <span class="hljs-type">u16</span>,              <span class="hljs-comment">// Network ID</span>
        tsid: <span class="hljs-type">u16</span>,             <span class="hljs-comment">// Transport Stream ID</span>
        sid: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u16</span>&gt;,      <span class="hljs-comment">// Service ID (任意、フィルタ用)</span>
    },
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">ChannelSelector</span> {
    <span class="hljs-comment">/// 物理指定かどうか</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_physical</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> {
        matches!(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">Self</span>::Physical { .. })
    }

    <span class="hljs-comment">/// DBのis_enabledを確認すべきか</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">should_check_enabled</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> {
        !<span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">is_physical</span>()  <span class="hljs-comment">// 論理指定のみチェック</span>
    }
}
</code></pre>
<h4 id="372-排他ロック機構">3.7.2 排他ロック機構</h4>
<p><strong>ロックの種類</strong>:</p>
<table>
<thead>
<tr>
<th>ロック種別</th>
<th>用途</th>
<th>競合</th>
</tr>
</thead>
<tbody>
<tr>
<td>Exclusive (排他)</td>
<td>物理指定でのチャンネル変更</td>
<td>全ロックと競合</td>
</tr>
<tr>
<td>Shared (共有)</td>
<td>論理指定での同一チャンネル視聴</td>
<td>Exclusiveのみ競合</td>
</tr>
</tbody>
</table>
<p><strong>ロック状態遷移</strong>:</p>
<pre><code>┌─────────────────────────────────────────────────────────────────────┐
│  チューナーロック状態遷移                                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   ┌──────────┐     acquire_exclusive()     ┌──────────────┐        │
│   │  Free    │ ──────────────────────────▶ │  Exclusive   │        │
│   │          │ ◀────────────────────────── │  (1 owner)   │        │
│   └──────────┘     release()               └──────────────┘        │
│        │                                          │                 │
│        │ acquire_shared()                         │                 │
│        ▼                                          │                 │
│   ┌──────────┐                                    │                 │
│   │  Shared  │ ◀─────────────────────────────────┘                 │
│   │  (N users)│     downgrade() (排他→共有)                        │
│   └──────────┘                                                      │
│        │                                                            │
│        │ last release()                                             │
│        ▼                                                            │
│   ┌──────────┐                                                      │
│   │  Free    │                                                      │
│   └──────────┘                                                      │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>実装</strong>:</p>
<pre><code class="language-rust"><span class="hljs-comment">// recisdb-proxy/src/tuner/lock.rs</span>

<span class="hljs-keyword">use</span> std::sync::Arc;
<span class="hljs-keyword">use</span> tokio::sync::{RwLock, Semaphore, OwnedSemaphorePermit};

<span class="hljs-comment">/// チューナーロック管理</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TunerLock</span> {
    <span class="hljs-comment">/// 排他/共有ロック用セマフォ</span>
    <span class="hljs-comment">/// - 排他: 全permitを取得</span>
    <span class="hljs-comment">/// - 共有: 1 permitのみ取得</span>
    semaphore: Arc&lt;Semaphore&gt;,
    max_permits: <span class="hljs-type">u32</span>,

    <span class="hljs-comment">/// 現在のチャンネル（共有判定用）</span>
    current_channel: RwLock&lt;<span class="hljs-type">Option</span>&lt;ChannelKey&gt;&gt;,

    <span class="hljs-comment">/// 共有クライアント数</span>
    shared_count: AtomicU32,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">TunerLock</span> {
    <span class="hljs-keyword">const</span> MAX_SHARED_CLIENTS: <span class="hljs-type">u32</span> = <span class="hljs-number">100</span>;

    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">Self</span> {
            semaphore: Arc::<span class="hljs-title function_ invoke__">new</span>(Semaphore::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-keyword">Self</span>::MAX_SHARED_CLIENTS <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>)),
            max_permits: <span class="hljs-keyword">Self</span>::MAX_SHARED_CLIENTS,
            current_channel: RwLock::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">None</span>),
            shared_count: AtomicU32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>),
        }
    }

    <span class="hljs-comment">/// 排他ロック取得（物理指定用）</span>
    <span class="hljs-comment">/// - 全クライアントが解放されるまで待機</span>
    <span class="hljs-comment">/// - チャンネル変更が可能</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">acquire_exclusive</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;ExclusiveLockGuard, LockError&gt; {
        <span class="hljs-comment">// 全permitを取得（排他）</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">permits</span> = <span class="hljs-keyword">self</span>.semaphore
            .<span class="hljs-title function_ invoke__">clone</span>()
            .<span class="hljs-title function_ invoke__">acquire_many_owned</span>(<span class="hljs-keyword">self</span>.max_permits)
            .<span class="hljs-keyword">await</span>
            .<span class="hljs-title function_ invoke__">map_err</span>(|_| LockError::Closed)?;

        <span class="hljs-title function_ invoke__">Ok</span>(ExclusiveLockGuard {
            _permits: permits,
            lock: <span class="hljs-keyword">self</span>,
        })
    }

    <span class="hljs-comment">/// 共有ロック取得（論理指定用）</span>
    <span class="hljs-comment">/// - 同一チャンネルなら即座に取得可能</span>
    <span class="hljs-comment">/// - 異なるチャンネルならエラー（別チューナーを探す）</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">acquire_shared</span>(
        &amp;<span class="hljs-keyword">self</span>,
        channel: &amp;ChannelKey,
    ) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;SharedLockGuard, LockError&gt; {
        <span class="hljs-comment">// 現在のチャンネルを確認</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">current</span> = <span class="hljs-keyword">self</span>.current_channel.<span class="hljs-title function_ invoke__">read</span>().<span class="hljs-keyword">await</span>;

        <span class="hljs-keyword">match</span> &amp;*current {
            <span class="hljs-title function_ invoke__">Some</span>(current_ch) <span class="hljs-keyword">if</span> current_ch == channel =&gt; {
                <span class="hljs-comment">// 同一チャンネル: 共有OK</span>
                <span class="hljs-title function_ invoke__">drop</span>(current);
            }
            <span class="hljs-title function_ invoke__">Some</span>(_) =&gt; {
                <span class="hljs-comment">// 異なるチャンネル: このチューナーは使用不可</span>
                <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(LockError::ChannelMismatch);
            }
            <span class="hljs-literal">None</span> =&gt; {
                <span class="hljs-comment">// 未使用: 排他ロックで初期化が必要</span>
                <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(LockError::NotInitialized);
            }
        }

        <span class="hljs-comment">// 1 permitを取得（共有）</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">permit</span> = <span class="hljs-keyword">self</span>.semaphore
            .<span class="hljs-title function_ invoke__">clone</span>()
            .<span class="hljs-title function_ invoke__">acquire_owned</span>()
            .<span class="hljs-keyword">await</span>
            .<span class="hljs-title function_ invoke__">map_err</span>(|_| LockError::Closed)?;

        <span class="hljs-keyword">self</span>.shared_count.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">1</span>, Ordering::SeqCst);

        <span class="hljs-title function_ invoke__">Ok</span>(SharedLockGuard {
            _permit: permit,
            lock: <span class="hljs-keyword">self</span>,
        })
    }

    <span class="hljs-comment">/// 排他ロック中にチャンネルを設定</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_channel</span>(&amp;<span class="hljs-keyword">self</span>, channel: ChannelKey) {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">current</span> = <span class="hljs-keyword">self</span>.current_channel.<span class="hljs-title function_ invoke__">write</span>().<span class="hljs-keyword">await</span>;
        *current = <span class="hljs-title function_ invoke__">Some</span>(channel);
    }

    <span class="hljs-comment">/// 排他→共有へダウングレード</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">downgrade</span>(
        guard: ExclusiveLockGuard&lt;<span class="hljs-symbol">&#x27;_</span>&gt;,
        channel: &amp;ChannelKey,
    ) <span class="hljs-punctuation">-&gt;</span> SharedLockGuard&lt;<span class="hljs-symbol">&#x27;_</span>&gt; {
        <span class="hljs-comment">// チャンネルを設定</span>
        guard.lock.<span class="hljs-title function_ invoke__">set_channel</span>(channel.<span class="hljs-title function_ invoke__">clone</span>()).<span class="hljs-keyword">await</span>;

        <span class="hljs-comment">// 排他ロックを解放し、共有ロックとして1 permitのみ保持</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">semaphore</span> = guard.lock.semaphore.<span class="hljs-title function_ invoke__">clone</span>();
        <span class="hljs-keyword">let</span> <span class="hljs-variable">permits_to_release</span> = guard.lock.max_permits - <span class="hljs-number">1</span>;

        <span class="hljs-comment">// ガードをドロップせずにpermitを部分解放</span>
        <span class="hljs-comment">// (実装の詳細は省略)</span>

        guard.lock.shared_count.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">1</span>, Ordering::SeqCst);

        SharedLockGuard {
            _permit: <span class="hljs-comment">/* 1 permit */</span>,
            lock: guard.lock,
        }
    }
}

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ExclusiveLockGuard</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; {
    _permits: OwnedSemaphorePermit,
    lock: &amp;<span class="hljs-symbol">&#x27;a</span> TunerLock,
}

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SharedLockGuard</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; {
    _permit: OwnedSemaphorePermit,
    lock: &amp;<span class="hljs-symbol">&#x27;a</span> TunerLock,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">SharedLockGuard</span>&lt;<span class="hljs-symbol">&#x27;_</span>&gt; {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">count</span> = <span class="hljs-keyword">self</span>.lock.shared_count.<span class="hljs-title function_ invoke__">fetch_sub</span>(<span class="hljs-number">1</span>, Ordering::SeqCst);
        <span class="hljs-keyword">if</span> count == <span class="hljs-number">1</span> {
            <span class="hljs-comment">// 最後の共有クライアント: チャンネルをクリア</span>
            <span class="hljs-comment">// (非同期コンテキスト外なのでspawnで処理)</span>
        }
    }
}

<span class="hljs-meta">#[derive(Debug, thiserror::Error)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">LockError</span> {
    <span class="hljs-meta">#[error(<span class="hljs-string">&quot;Tuner is locked on different channel&quot;</span>)]</span>
    ChannelMismatch,
    <span class="hljs-meta">#[error(<span class="hljs-string">&quot;Tuner not initialized (needs exclusive lock first)&quot;</span>)]</span>
    NotInitialized,
    <span class="hljs-meta">#[error(<span class="hljs-string">&quot;Lock system closed&quot;</span>)]</span>
    Closed,
    <span class="hljs-meta">#[error(<span class="hljs-string">&quot;Lock timeout&quot;</span>)]</span>
    Timeout,
}
</code></pre>
<h4 id="373-論理指定でのチューナー自動選択">3.7.3 論理指定でのチューナー自動選択</h4>
<p><strong>選択アルゴリズム（フォールバック付き）</strong>:</p>
<pre><code>┌─────────────────────────────────────────────────────────────────────┐
│  NID/TSID → 最適チューナー選択 アルゴリズム（フォールバック対応）     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. DBから該当NID/TSIDを持つチャンネルを検索                         │
│     └── is_enabled = 1 のみ対象                                     │
│                                                                     │
│  2. チャンネル選択優先度でソート                                     │
│     └── channels.priority DESC                                      │
│     └── bon_drivers.scan_priority DESC (同一優先度の場合)           │
│                                                                     │
│  3. 各候補について:                                                  │
│     a. 同一チャンネルで共有ロック中 → 即座に共有参加 ✓               │
│     b. チューナーがFree:                                            │
│        i.   排他ロック取得                                          │
│        ii.  SetChannel実行                                          │
│        iii. 信号レベル確認 (signal_level &gt;= threshold?)             │
│        iv.  TSパケット受信確認 (timeout内に受信できたか?)           │
│        v.   成功 → 共有化して返却 ✓                                 │
│        vi.  失敗 → ロック解放、failure_count++、次の候補へ          │
│     c. 異なるチャンネルでロック中 → 次の候補へ                       │
│                                                                     │
│  4. 全候補で失敗 → エラー返却                                        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>フォールバック条件</strong>:</p>
<table>
<thead>
<tr>
<th>条件</th>
<th>動作</th>
<th>DB更新</th>
</tr>
</thead>
<tbody>
<tr>
<td>ロック取得失敗（別チャンネル使用中）</td>
<td>次の候補へ</td>
<td>なし</td>
</tr>
<tr>
<td>SetChannel失敗</td>
<td>ロック解放、次の候補へ</td>
<td>failure_count++</td>
</tr>
<tr>
<td>信号レベル &lt; threshold</td>
<td>ロック解放、次の候補へ</td>
<td>failure_count++</td>
</tr>
<tr>
<td>TSパケット受信タイムアウト</td>
<td>ロック解放、次の候補へ</td>
<td>failure_count++</td>
</tr>
<tr>
<td>failure_count &gt;= max_failures</td>
<td>候補から除外</td>
<td>is_enabled=0</td>
</tr>
</tbody>
</table>
<p><strong>インデックス追加</strong> (channelsテーブル - priorityは3.1のスキーマで定義済み):</p>
<pre><code class="language-sql"><span class="hljs-comment">-- 優先度付きインデックス（論理指定での高速検索用）</span>
<span class="hljs-keyword">CREATE</span> INDEX idx_channels_nid_tsid_priority
<span class="hljs-keyword">ON</span> channels(nid, tsid, priority <span class="hljs-keyword">DESC</span>, is_enabled);
</code></pre>
<p><strong>実装</strong>:</p>
<pre><code class="language-rust"><span class="hljs-comment">// recisdb-proxy/src/tuner/selector.rs</span>

<span class="hljs-keyword">use</span> crate::database::Database;
<span class="hljs-keyword">use</span> crate::tuner::{TunerPool, TunerLock, ChannelKey};

<span class="hljs-keyword">const</span> SIGNAL_THRESHOLD: <span class="hljs-type">f64</span> = <span class="hljs-number">5.0</span>;
<span class="hljs-keyword">const</span> TUNE_TIMEOUT_MS: <span class="hljs-type">u64</span> = <span class="hljs-number">3000</span>;
<span class="hljs-keyword">const</span> TS_RECEIVE_TIMEOUT_MS: <span class="hljs-type">u64</span> = <span class="hljs-number">2000</span>;
<span class="hljs-keyword">const</span> MAX_FAILURE_COUNT: <span class="hljs-type">i32</span> = <span class="hljs-number">5</span>;

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TunerSelector</span> {
    db: Arc&lt;Database&gt;,
    tuner_pool: Arc&lt;TunerPool&gt;,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">TunerSelector</span> {
    <span class="hljs-comment">/// 論理指定でチューナーを選択・ロック取得（フォールバック対応）</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">select_by_logical</span>(
        &amp;<span class="hljs-keyword">self</span>,
        nid: <span class="hljs-type">u16</span>,
        tsid: <span class="hljs-type">u16</span>,
        sid: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u16</span>&gt;,
    ) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;SelectedTuner, SelectError&gt; {
        <span class="hljs-comment">// 1. DBから候補チャンネルを優先度順に取得</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">candidates</span> = <span class="hljs-keyword">self</span>.db.<span class="hljs-title function_ invoke__">get_channels_by_nid_tsid_ordered</span>(nid, tsid, sid)?;

        <span class="hljs-keyword">if</span> candidates.<span class="hljs-title function_ invoke__">is_empty</span>() {
            <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(SelectError::ChannelNotFound { nid, tsid });
        }

        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">last_error</span> = <span class="hljs-literal">None</span>;

        <span class="hljs-comment">// 2. 各候補を試行（フォールバック）</span>
        <span class="hljs-keyword">for</span> <span class="hljs-variable">candidate</span> <span class="hljs-keyword">in</span> &amp;candidates {
            <span class="hljs-keyword">let</span> <span class="hljs-variable">tuner_id</span> = &amp;candidate.bon_driver_path;
            <span class="hljs-keyword">let</span> <span class="hljs-variable">channel_key</span> = ChannelKey {
                tuner_id: tuner_id.<span class="hljs-title function_ invoke__">clone</span>(),
                space: candidate.bon_space.<span class="hljs-title function_ invoke__">unwrap_or</span>(<span class="hljs-number">0</span>),
                channel: candidate.bon_channel.<span class="hljs-title function_ invoke__">unwrap_or</span>(<span class="hljs-number">0</span>),
            };

            <span class="hljs-comment">// チューナーを取得</span>
            <span class="hljs-keyword">let</span> <span class="hljs-variable">tuner</span> = <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.tuner_pool.<span class="hljs-title function_ invoke__">get_tuner</span>(tuner_id).<span class="hljs-keyword">await</span> {
                <span class="hljs-title function_ invoke__">Some</span>(t) =&gt; t,
                <span class="hljs-literal">None</span> =&gt; {
                    debug!(<span class="hljs-string">&quot;Tuner not found: {}, trying next&quot;</span>, tuner_id);
                    <span class="hljs-keyword">continue</span>;
                }
            };

            <span class="hljs-comment">// 3a. 同一チャンネルで共有中なら参加（既にTS受信中なので検証不要）</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(guard) = tuner.lock.<span class="hljs-title function_ invoke__">acquire_shared</span>(&amp;channel_key).<span class="hljs-keyword">await</span> {
                info!(<span class="hljs-string">&quot;Joined existing shared tuner: {} for NID={}, TSID={}&quot;</span>,
                    tuner_id, nid, tsid);
                <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(SelectedTuner {
                    tuner,
                    guard: LockGuard::<span class="hljs-title function_ invoke__">Shared</span>(guard),
                    channel_info: candidate.<span class="hljs-title function_ invoke__">clone</span>(),
                });
            }

            <span class="hljs-comment">// 3b. Freeなら排他ロック→チャンネル設定→検証→共有化</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(exclusive) = tuner.lock.<span class="hljs-title function_ invoke__">try_acquire_exclusive</span>().<span class="hljs-keyword">await</span> {
                <span class="hljs-comment">// チャンネル設定を試行</span>
                <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">try_tune_and_verify</span>(
                    &amp;tuner,
                    candidate.bon_space.<span class="hljs-title function_ invoke__">unwrap_or</span>(<span class="hljs-number">0</span>),
                    candidate.bon_channel.<span class="hljs-title function_ invoke__">unwrap_or</span>(<span class="hljs-number">0</span>),
                ).<span class="hljs-keyword">await</span> {
                    <span class="hljs-title function_ invoke__">Ok</span>(()) =&gt; {
                        <span class="hljs-comment">// 成功: 共有ロックへダウングレード</span>
                        <span class="hljs-keyword">let</span> <span class="hljs-variable">shared</span> = TunerLock::<span class="hljs-title function_ invoke__">downgrade</span>(exclusive, &amp;channel_key).<span class="hljs-keyword">await</span>;

                        <span class="hljs-comment">// failure_countをリセット</span>
                        <span class="hljs-keyword">self</span>.db.<span class="hljs-title function_ invoke__">reset_failure_count</span>(candidate.id).<span class="hljs-title function_ invoke__">ok</span>();

                        info!(<span class="hljs-string">&quot;Successfully tuned: {} for NID={}, TSID={}&quot;</span>,
                            tuner_id, nid, tsid);

                        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(SelectedTuner {
                            tuner,
                            guard: LockGuard::<span class="hljs-title function_ invoke__">Shared</span>(shared),
                            channel_info: candidate.<span class="hljs-title function_ invoke__">clone</span>(),
                        });
                    }
                    <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; {
                        <span class="hljs-comment">// 失敗: ロックは自動解放（exclusive drop）</span>
                        warn!(<span class="hljs-string">&quot;Tune failed for {} (NID={}, TSID={}): {}, trying next&quot;</span>,
                            tuner_id, nid, tsid, e);

                        <span class="hljs-comment">// failure_countをインクリメント</span>
                        <span class="hljs-keyword">let</span> <span class="hljs-variable">new_count</span> = <span class="hljs-keyword">self</span>.db.<span class="hljs-title function_ invoke__">increment_failure_count</span>(candidate.id)?;

                        <span class="hljs-comment">// 閾値を超えたらチャンネルを無効化</span>
                        <span class="hljs-keyword">if</span> new_count &gt;= MAX_FAILURE_COUNT {
                            warn!(<span class="hljs-string">&quot;Disabling channel {} due to {} consecutive failures&quot;</span>,
                                candidate.id, new_count);
                            <span class="hljs-keyword">self</span>.db.<span class="hljs-title function_ invoke__">disable_channel</span>(candidate.id)?;
                        }

                        last_error = <span class="hljs-title function_ invoke__">Some</span>(e);
                        <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 次の候補へフォールバック</span>
                    }
                }
            }

            <span class="hljs-comment">// 3c. ロック取得失敗（別チャンネル使用中）、次の候補へ</span>
            debug!(<span class="hljs-string">&quot;Tuner {} is busy with different channel, trying next&quot;</span>, tuner_id);
        }

        <span class="hljs-comment">// 4. 全候補で失敗</span>
        <span class="hljs-title function_ invoke__">Err</span>(last_error.<span class="hljs-title function_ invoke__">map</span>(SelectError::TuneFailed)
            .<span class="hljs-title function_ invoke__">unwrap_or</span>(SelectError::AllTunersBusy))
    }

    <span class="hljs-comment">/// チューニング実行＋信号・TS受信検証</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">try_tune_and_verify</span>(
        &amp;<span class="hljs-keyword">self</span>,
        tuner: &amp;SharedTuner,
        space: <span class="hljs-type">u32</span>,
        channel: <span class="hljs-type">u32</span>,
    ) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), TuneError&gt; {
        <span class="hljs-comment">// Step 1: SetChannel</span>
        tuner.<span class="hljs-title function_ invoke__">set_channel</span>(space, channel).<span class="hljs-keyword">await</span>
            .<span class="hljs-title function_ invoke__">map_err</span>(|e| TuneError::<span class="hljs-title function_ invoke__">SetChannelFailed</span>(e.<span class="hljs-title function_ invoke__">to_string</span>()))?;

        <span class="hljs-comment">// Step 2: 信号ロック待機</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">lock_start</span> = Instant::<span class="hljs-title function_ invoke__">now</span>();
        <span class="hljs-keyword">let</span> <span class="hljs-variable">lock_timeout</span> = Duration::<span class="hljs-title function_ invoke__">from_millis</span>(TUNE_TIMEOUT_MS);

        <span class="hljs-keyword">loop</span> {
            <span class="hljs-keyword">if</span> lock_start.<span class="hljs-title function_ invoke__">elapsed</span>() &gt; lock_timeout {
                <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(TuneError::SignalLockTimeout);
            }

            <span class="hljs-keyword">let</span> <span class="hljs-variable">signal</span> = tuner.<span class="hljs-title function_ invoke__">get_signal_level</span>().<span class="hljs-keyword">await</span>;
            <span class="hljs-keyword">if</span> signal &gt;= SIGNAL_THRESHOLD {
                <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 信号ロック成功</span>
            }

            tokio::time::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">100</span>)).<span class="hljs-keyword">await</span>;
        }

        <span class="hljs-comment">// Step 3: TSパケット受信確認</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">ts_start</span> = Instant::<span class="hljs-title function_ invoke__">now</span>();
        <span class="hljs-keyword">let</span> <span class="hljs-variable">ts_timeout</span> = Duration::<span class="hljs-title function_ invoke__">from_millis</span>(TS_RECEIVE_TIMEOUT_MS);

        <span class="hljs-keyword">loop</span> {
            <span class="hljs-keyword">if</span> ts_start.<span class="hljs-title function_ invoke__">elapsed</span>() &gt; ts_timeout {
                <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(TuneError::TsReceiveTimeout);
            }

            <span class="hljs-keyword">if</span> tuner.<span class="hljs-title function_ invoke__">has_received_ts_packets</span>().<span class="hljs-keyword">await</span> {
                <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// TS受信確認</span>
            }

            tokio::time::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">50</span>)).<span class="hljs-keyword">await</span>;
        }

        <span class="hljs-title function_ invoke__">Ok</span>(())
    }
}

<span class="hljs-meta">#[derive(Debug, thiserror::Error)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">TuneError</span> {
    <span class="hljs-meta">#[error(<span class="hljs-string">&quot;SetChannel failed: {0}&quot;</span>)]</span>
    <span class="hljs-title function_ invoke__">SetChannelFailed</span>(<span class="hljs-type">String</span>),
    <span class="hljs-meta">#[error(<span class="hljs-string">&quot;Signal lock timeout (no signal or weak signal)&quot;</span>)]</span>
    SignalLockTimeout,
    <span class="hljs-meta">#[error(<span class="hljs-string">&quot;TS packet receive timeout&quot;</span>)]</span>
    TsReceiveTimeout,
}

<span class="hljs-meta">#[derive(Debug, thiserror::Error)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">SelectError</span> {
    <span class="hljs-meta">#[error(<span class="hljs-string">&quot;Channel not found: NID={nid}, TSID={tsid}&quot;</span>)]</span>
    ChannelNotFound { nid: <span class="hljs-type">u16</span>, tsid: <span class="hljs-type">u16</span> },
    <span class="hljs-meta">#[error(<span class="hljs-string">&quot;All tuners are busy&quot;</span>)]</span>
    AllTunersBusy,
    <span class="hljs-meta">#[error(<span class="hljs-string">&quot;Tune failed: {0}&quot;</span>)]</span>
    <span class="hljs-title function_ invoke__">TuneFailed</span>(TuneError),
    <span class="hljs-meta">#[error(<span class="hljs-string">&quot;Tuner not found: {0}&quot;</span>)]</span>
    <span class="hljs-title function_ invoke__">TunerNotFound</span>(<span class="hljs-type">String</span>),
    <span class="hljs-meta">#[error(<span class="hljs-string">&quot;Lock failed: {0}&quot;</span>)]</span>
    <span class="hljs-title function_ invoke__">LockFailed</span>(LockError),
}

<span class="hljs-comment">// Database側</span>
<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Database</span> {
    <span class="hljs-comment">/// failure_countをインクリメント</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">increment_failure_count</span>(&amp;<span class="hljs-keyword">self</span>, channel_id: <span class="hljs-type">i64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">i32</span>&gt; {
        <span class="hljs-keyword">self</span>.conn.<span class="hljs-title function_ invoke__">execute</span>(
            <span class="hljs-string">&quot;UPDATE channels SET failure_count = failure_count + 1 WHERE id = ?&quot;</span>,
            [channel_id],
        )?;

        <span class="hljs-keyword">let</span> <span class="hljs-variable">count</span>: <span class="hljs-type">i32</span> = <span class="hljs-keyword">self</span>.conn.<span class="hljs-title function_ invoke__">query_row</span>(
            <span class="hljs-string">&quot;SELECT failure_count FROM channels WHERE id = ?&quot;</span>,
            [channel_id],
            |row| row.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">0</span>),
        )?;

        <span class="hljs-title function_ invoke__">Ok</span>(count)
    }

    <span class="hljs-comment">/// failure_countをリセット</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">reset_failure_count</span>(&amp;<span class="hljs-keyword">self</span>, channel_id: <span class="hljs-type">i64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt; {
        <span class="hljs-keyword">self</span>.conn.<span class="hljs-title function_ invoke__">execute</span>(
            <span class="hljs-string">&quot;UPDATE channels SET failure_count = 0, last_seen = strftime(&#x27;%s&#x27;, &#x27;now&#x27;) WHERE id = ?&quot;</span>,
            [channel_id],
        )?;
        <span class="hljs-title function_ invoke__">Ok</span>(())
    }
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">TunerSelector</span> {
    <span class="hljs-comment">/// 物理指定でチューナーを選択・排他ロック取得</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">select_by_physical</span>(
        &amp;<span class="hljs-keyword">self</span>,
        tuner_id: &amp;<span class="hljs-type">str</span>,
        space: <span class="hljs-type">u32</span>,
        channel: <span class="hljs-type">u32</span>,
    ) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;SelectedTuner, SelectError&gt; {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">tuner</span> = <span class="hljs-keyword">self</span>.tuner_pool.<span class="hljs-title function_ invoke__">get_tuner</span>(tuner_id).<span class="hljs-keyword">await</span>
            .<span class="hljs-title function_ invoke__">ok_or_else</span>(|| SelectError::<span class="hljs-title function_ invoke__">TunerNotFound</span>(tuner_id.<span class="hljs-title function_ invoke__">to_string</span>()))?;

        <span class="hljs-comment">// 排他ロック取得（待機）</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">exclusive</span> = tuner.lock.<span class="hljs-title function_ invoke__">acquire_exclusive</span>().<span class="hljs-keyword">await</span>
            .<span class="hljs-title function_ invoke__">map_err</span>(|e| SelectError::<span class="hljs-title function_ invoke__">LockFailed</span>(e))?;

        <span class="hljs-comment">// チャンネル設定（DBの有効/無効を無視）</span>
        tuner.<span class="hljs-title function_ invoke__">set_channel</span>(space, channel).<span class="hljs-keyword">await</span>?;

        <span class="hljs-keyword">let</span> <span class="hljs-variable">channel_key</span> = ChannelKey {
            tuner_id: tuner_id.<span class="hljs-title function_ invoke__">to_string</span>(),
            space,
            channel,
        };

        <span class="hljs-comment">// DBからチャンネル情報を取得（あれば）</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">channel_info</span> = <span class="hljs-keyword">self</span>.db.<span class="hljs-title function_ invoke__">get_channel_by_physical</span>(tuner_id, space, channel)
            .<span class="hljs-title function_ invoke__">ok</span>()
            .<span class="hljs-title function_ invoke__">flatten</span>();

        <span class="hljs-comment">// 共有ロックへダウングレード（他クライアントも参加可能に）</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">shared</span> = TunerLock::<span class="hljs-title function_ invoke__">downgrade</span>(exclusive, &amp;channel_key).<span class="hljs-keyword">await</span>;

        <span class="hljs-title function_ invoke__">Ok</span>(SelectedTuner {
            tuner,
            guard: LockGuard::<span class="hljs-title function_ invoke__">Shared</span>(shared),
            channel_info,
        })
    }
}

<span class="hljs-comment">// Database側</span>
<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Database</span> {
    <span class="hljs-comment">/// NID/TSIDで優先度順にチャンネルを取得</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_channels_by_nid_tsid_ordered</span>(
        &amp;<span class="hljs-keyword">self</span>,
        nid: <span class="hljs-type">u16</span>,
        tsid: <span class="hljs-type">u16</span>,
        sid: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u16</span>&gt;,
    ) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Vec</span>&lt;ChannelWithDriver&gt;&gt; {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">query</span> = String::<span class="hljs-title function_ invoke__">from</span>(
            <span class="hljs-string">&quot;SELECT c.*, bd.dll_path as bon_driver_path, bd.scan_priority
             FROM channels c
             JOIN bon_drivers bd ON c.bon_driver_id = bd.id
             WHERE c.nid = ? AND c.tsid = ? AND c.is_enabled = 1&quot;</span>
        );

        <span class="hljs-keyword">if</span> sid.<span class="hljs-title function_ invoke__">is_some</span>() {
            query.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot; AND c.sid = ?&quot;</span>);
        }

        query.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot; ORDER BY c.priority DESC, bd.scan_priority DESC&quot;</span>);

        <span class="hljs-comment">// ... 実行</span>
    }
}
</code></pre>
<h4 id="374-クライアント側のチャンネルリスト同期">3.7.4 クライアント側のチャンネルリスト同期</h4>
<p><strong>プロトコル拡張</strong>:</p>
<pre><code class="language-rust"><span class="hljs-comment">// recisdb-protocol/src/types.rs に追加</span>

<span class="hljs-comment">/// チャンネルリスト同期用メッセージ</span>
<span class="hljs-meta">#[derive(Debug, Clone, Serialize, Deserialize)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ChannelListMessage</span> {
    <span class="hljs-comment">/// クライアント→サーバー: チャンネルリスト要求</span>
    Request {
        <span class="hljs-comment">/// フィルタ条件（任意）</span>
        filter: <span class="hljs-type">Option</span>&lt;ChannelFilter&gt;,
    },

    <span class="hljs-comment">/// サーバー→クライアント: チャンネルリスト応答</span>
    Response {
        channels: <span class="hljs-type">Vec</span>&lt;ClientChannelInfo&gt;,
        <span class="hljs-comment">/// リスト生成時刻（差分更新用）</span>
        timestamp: <span class="hljs-type">i64</span>,
    },

    <span class="hljs-comment">/// サーバー→クライアント: 差分更新通知</span>
    Update {
        added: <span class="hljs-type">Vec</span>&lt;ClientChannelInfo&gt;,
        updated: <span class="hljs-type">Vec</span>&lt;ClientChannelInfo&gt;,
        removed: <span class="hljs-type">Vec</span>&lt;ChannelKey&gt;,
        timestamp: <span class="hljs-type">i64</span>,
    },
}

<span class="hljs-meta">#[derive(Debug, Clone, Serialize, Deserialize)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ChannelFilter</span> {
    <span class="hljs-keyword">pub</span> nid: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u16</span>&gt;,
    <span class="hljs-keyword">pub</span> tsid: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u16</span>&gt;,
    <span class="hljs-keyword">pub</span> network_type: <span class="hljs-type">Option</span>&lt;NetworkType&gt;,  <span class="hljs-comment">// Terrestrial, BS, CS</span>
    <span class="hljs-keyword">pub</span> enabled_only: <span class="hljs-type">bool</span>,
}

<span class="hljs-comment">/// クライアントに送信するチャンネル情報</span>
<span class="hljs-meta">#[derive(Debug, Clone, Serialize, Deserialize)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ClientChannelInfo</span> {
    <span class="hljs-comment">// 識別子</span>
    <span class="hljs-keyword">pub</span> nid: <span class="hljs-type">u16</span>,
    <span class="hljs-keyword">pub</span> sid: <span class="hljs-type">u16</span>,
    <span class="hljs-keyword">pub</span> tsid: <span class="hljs-type">u16</span>,

    <span class="hljs-comment">// 表示用</span>
    <span class="hljs-keyword">pub</span> channel_name: <span class="hljs-type">String</span>,
    <span class="hljs-keyword">pub</span> network_name: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,
    <span class="hljs-keyword">pub</span> service_type: <span class="hljs-type">u8</span>,
    <span class="hljs-keyword">pub</span> remote_control_key: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u8</span>&gt;,

    <span class="hljs-comment">// BonDriver互換用（TVTest表示用）</span>
    <span class="hljs-keyword">pub</span> space_name: <span class="hljs-type">String</span>,          <span class="hljs-comment">// &quot;BS&quot; / &quot;CS&quot; / &quot;地デジ&quot; など</span>
    <span class="hljs-keyword">pub</span> channel_display_name: <span class="hljs-type">String</span>, <span class="hljs-comment">// &quot;BS朝日&quot; など</span>

    <span class="hljs-comment">// 優先度</span>
    <span class="hljs-keyword">pub</span> priority: <span class="hljs-type">i32</span>,
}
</code></pre>
<p><strong>クライアント側実装</strong> (bondriver-proxy-client):</p>
<pre><code class="language-rust"><span class="hljs-comment">// bondriver-proxy-client/src/client/channel_cache.rs</span>

<span class="hljs-keyword">use</span> std::collections::HashMap;

<span class="hljs-comment">/// クライアント側チャンネルキャッシュ</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ChannelCache</span> {
    <span class="hljs-comment">/// NID-TSID → チャンネル情報マップ</span>
    channels: HashMap&lt;(<span class="hljs-type">u16</span>, <span class="hljs-type">u16</span>), <span class="hljs-type">Vec</span>&lt;ClientChannelInfo&gt;&gt;,

    <span class="hljs-comment">/// Space/Channel → NID-TSID マッピング（BonDriver互換用）</span>
    physical_to_logical: HashMap&lt;(<span class="hljs-type">u32</span>, <span class="hljs-type">u32</span>), (<span class="hljs-type">u16</span>, <span class="hljs-type">u16</span>, <span class="hljs-type">u16</span>)&gt;,

    <span class="hljs-comment">/// 最終同期時刻</span>
    last_sync: <span class="hljs-type">i64</span>,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">ChannelCache</span> {
    <span class="hljs-comment">/// サーバーからチャンネルリストを同期</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sync</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, client: &amp;<span class="hljs-keyword">mut</span> ProxyClient) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt; {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">response</span> = client.<span class="hljs-title function_ invoke__">send</span>(ChannelListMessage::Request {
            filter: <span class="hljs-title function_ invoke__">Some</span>(ChannelFilter {
                enabled_only: <span class="hljs-literal">true</span>,
                ..<span class="hljs-built_in">Default</span>::<span class="hljs-title function_ invoke__">default</span>()
            }),
        }).<span class="hljs-keyword">await</span>?;

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">ChannelListMessage</span>::Response { channels, timestamp } = response {
            <span class="hljs-keyword">self</span>.channels.<span class="hljs-title function_ invoke__">clear</span>();
            <span class="hljs-keyword">self</span>.physical_to_logical.<span class="hljs-title function_ invoke__">clear</span>();

            <span class="hljs-keyword">for</span> <span class="hljs-variable">ch</span> <span class="hljs-keyword">in</span> channels {
                <span class="hljs-comment">// NID-TSID でグループ化</span>
                <span class="hljs-keyword">self</span>.channels
                    .<span class="hljs-title function_ invoke__">entry</span>((ch.nid, ch.tsid))
                    .<span class="hljs-title function_ invoke__">or_default</span>()
                    .<span class="hljs-title function_ invoke__">push</span>(ch.<span class="hljs-title function_ invoke__">clone</span>());

                <span class="hljs-comment">// Space/Channel マッピング構築（BonDriver互換）</span>
                <span class="hljs-comment">// TVTestはSpace/Channelでアクセスするため</span>
            }

            <span class="hljs-keyword">self</span>.last_sync = timestamp;
        }

        <span class="hljs-title function_ invoke__">Ok</span>(())
    }

    <span class="hljs-comment">/// NID-TSIDからチャンネル情報を取得</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_by_nid_tsid</span>(&amp;<span class="hljs-keyword">self</span>, nid: <span class="hljs-type">u16</span>, tsid: <span class="hljs-type">u16</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;[ClientChannelInfo]&gt; {
        <span class="hljs-keyword">self</span>.channels.<span class="hljs-title function_ invoke__">get</span>(&amp;(nid, tsid)).<span class="hljs-title function_ invoke__">map</span>(|v| v.<span class="hljs-title function_ invoke__">as_slice</span>())
    }

    <span class="hljs-comment">/// BonDriverのSpace/ChannelからNID-TSID-SIDを解決</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">resolve_physical</span>(&amp;<span class="hljs-keyword">self</span>, space: <span class="hljs-type">u32</span>, channel: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;(<span class="hljs-type">u16</span>, <span class="hljs-type">u16</span>, <span class="hljs-type">u16</span>)&gt; {
        <span class="hljs-keyword">self</span>.physical_to_logical.<span class="hljs-title function_ invoke__">get</span>(&amp;(space, channel)).<span class="hljs-title function_ invoke__">copied</span>()
    }
}
</code></pre>
<p><strong>NIDによる放送種別・地域判定</strong>:</p>
<pre><code class="language-rust"><span class="hljs-comment">// recisdb-protocol/src/broadcast_region.rs</span>

<span class="hljs-comment">/// 放送種別</span>
<span class="hljs-meta">#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">BroadcastType</span> {
    Terrestrial,  <span class="hljs-comment">// 地上波</span>
    BS,           <span class="hljs-comment">// BS</span>
    CS,           <span class="hljs-comment">// CS (CS1, CS2)</span>
}

<span class="hljs-comment">/// 放送地域 (地上波のみ)</span>
<span class="hljs-meta">#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">TerrestrialRegion</span> {
    Hokkaido,      <span class="hljs-comment">// 北海道</span>
    Tohoku,        <span class="hljs-comment">// 東北</span>
    Kanto,         <span class="hljs-comment">// 関東広域</span>
    Koshinetsu,    <span class="hljs-comment">// 甲信越</span>
    Hokuriku,      <span class="hljs-comment">// 北陸</span>
    Tokai,         <span class="hljs-comment">// 東海</span>
    Kinki,         <span class="hljs-comment">// 近畿広域</span>
    Chugoku,       <span class="hljs-comment">// 中国</span>
    Shikoku,       <span class="hljs-comment">// 四国</span>
    Kyushu,        <span class="hljs-comment">// 九州</span>
    Okinawa,       <span class="hljs-comment">// 沖縄</span>
    <span class="hljs-title function_ invoke__">Unknown</span>(<span class="hljs-type">u16</span>),  <span class="hljs-comment">// 不明なNID</span>
}

<span class="hljs-comment">/// NIDから放送種別・地域を判定</span>
<span class="hljs-comment">/// 参考: ARIB TR-B14, TR-B15</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">classify_nid</span>(nid: <span class="hljs-type">u16</span>) <span class="hljs-punctuation">-&gt;</span> (BroadcastType, <span class="hljs-type">Option</span>&lt;TerrestrialRegion&gt;) {
    <span class="hljs-keyword">match</span> nid {
        <span class="hljs-comment">// BS (NID = 4)</span>
        <span class="hljs-number">4</span> =&gt; (BroadcastType::BS, <span class="hljs-literal">None</span>),

        <span class="hljs-comment">// CS (NID = 6, 7, 10)</span>
        <span class="hljs-number">6</span> | <span class="hljs-number">7</span> | <span class="hljs-number">10</span> =&gt; (BroadcastType::CS, <span class="hljs-literal">None</span>),

        <span class="hljs-comment">// 地上波 (NID = 0x7FE0 ~ 0x7FFF: 地域別)</span>
        <span class="hljs-comment">// 上位4ビット = 0x7, 下位12ビットで地域識別</span>
        <span class="hljs-number">0x7FE0</span>..=<span class="hljs-number">0x7FFF</span> =&gt; {
            <span class="hljs-keyword">let</span> <span class="hljs-variable">region</span> = <span class="hljs-keyword">match</span> nid {
                <span class="hljs-comment">// 北海道 (複数NID)</span>
                <span class="hljs-number">0x7FE0</span>..=<span class="hljs-number">0x7FE7</span> =&gt; TerrestrialRegion::Hokkaido,
                <span class="hljs-comment">// 関東広域圏</span>
                <span class="hljs-number">0x7FE8</span> =&gt; TerrestrialRegion::Kanto,
                <span class="hljs-comment">// 近畿広域圏</span>
                <span class="hljs-number">0x7FE9</span> =&gt; TerrestrialRegion::Kinki,
                <span class="hljs-comment">// 中京広域圏 (東海)</span>
                <span class="hljs-number">0x7FEA</span> =&gt; TerrestrialRegion::Tokai,
                <span class="hljs-comment">// 岡山・香川</span>
                <span class="hljs-number">0x7FEB</span> =&gt; TerrestrialRegion::Chugoku,
                <span class="hljs-comment">// 島根・鳥取</span>
                <span class="hljs-number">0x7FEC</span> =&gt; TerrestrialRegion::Chugoku,
                <span class="hljs-comment">// 北海道 (追加)</span>
                <span class="hljs-number">0x7FF0</span>..=<span class="hljs-number">0x7FF7</span> =&gt; TerrestrialRegion::Hokkaido,
                <span class="hljs-comment">// その他</span>
                _ =&gt; TerrestrialRegion::<span class="hljs-title function_ invoke__">Unknown</span>(nid),
            };
            (BroadcastType::Terrestrial, <span class="hljs-title function_ invoke__">Some</span>(region))
        }

        <span class="hljs-comment">// 県域放送 (NID = 32721 ~ 32767: 0x7FD1 ~ 0x7FFF の一部)</span>
        <span class="hljs-comment">// 詳細な地域マッピングは別途定義</span>
        _ =&gt; {
            <span class="hljs-comment">// 不明なNIDは地上波として扱う</span>
            <span class="hljs-keyword">if</span> nid &gt;= <span class="hljs-number">0x7F00</span> {
                (BroadcastType::Terrestrial, <span class="hljs-title function_ invoke__">Some</span>(TerrestrialRegion::<span class="hljs-title function_ invoke__">Unknown</span>(nid)))
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 完全に不明</span>
                (BroadcastType::Terrestrial, <span class="hljs-title function_ invoke__">Some</span>(TerrestrialRegion::<span class="hljs-title function_ invoke__">Unknown</span>(nid)))
            }
        }
    }
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">TerrestrialRegion</span> {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">display_name</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> {
        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {
            <span class="hljs-keyword">Self</span>::Hokkaido =&gt; <span class="hljs-string">&quot;北海道&quot;</span>,
            <span class="hljs-keyword">Self</span>::Tohoku =&gt; <span class="hljs-string">&quot;東北&quot;</span>,
            <span class="hljs-keyword">Self</span>::Kanto =&gt; <span class="hljs-string">&quot;関東&quot;</span>,
            <span class="hljs-keyword">Self</span>::Koshinetsu =&gt; <span class="hljs-string">&quot;甲信越&quot;</span>,
            <span class="hljs-keyword">Self</span>::Hokuriku =&gt; <span class="hljs-string">&quot;北陸&quot;</span>,
            <span class="hljs-keyword">Self</span>::Tokai =&gt; <span class="hljs-string">&quot;東海&quot;</span>,
            <span class="hljs-keyword">Self</span>::Kinki =&gt; <span class="hljs-string">&quot;近畿&quot;</span>,
            <span class="hljs-keyword">Self</span>::Chugoku =&gt; <span class="hljs-string">&quot;中国&quot;</span>,
            <span class="hljs-keyword">Self</span>::Shikoku =&gt; <span class="hljs-string">&quot;四国&quot;</span>,
            <span class="hljs-keyword">Self</span>::Kyushu =&gt; <span class="hljs-string">&quot;九州&quot;</span>,
            <span class="hljs-keyword">Self</span>::Okinawa =&gt; <span class="hljs-string">&quot;沖縄&quot;</span>,
            <span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">Unknown</span>(_) =&gt; <span class="hljs-string">&quot;その他&quot;</span>,
        }
    }
}
</code></pre>
<p><strong>チューナー空間の自動生成</strong>:</p>
<pre><code class="language-rust"><span class="hljs-comment">// bondriver-proxy-client/src/client/space_builder.rs</span>

<span class="hljs-keyword">use</span> std::collections::{HashMap, BTreeMap};
<span class="hljs-keyword">use</span> crate::broadcast_region::{BroadcastType, TerrestrialRegion, classify_nid};

<span class="hljs-comment">/// 自動生成されたチューナー空間</span>
<span class="hljs-meta">#[derive(Debug, Clone)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TuningSpace</span> {
    <span class="hljs-keyword">pub</span> space_id: <span class="hljs-type">u32</span>,
    <span class="hljs-keyword">pub</span> name: <span class="hljs-type">String</span>,
    <span class="hljs-keyword">pub</span> broadcast_type: BroadcastType,
    <span class="hljs-keyword">pub</span> region: <span class="hljs-type">Option</span>&lt;TerrestrialRegion&gt;,
    <span class="hljs-keyword">pub</span> channels: <span class="hljs-type">Vec</span>&lt;SpaceChannel&gt;,
}

<span class="hljs-meta">#[derive(Debug, Clone)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SpaceChannel</span> {
    <span class="hljs-keyword">pub</span> index: <span class="hljs-type">u32</span>,           <span class="hljs-comment">// Space内のインデックス</span>
    <span class="hljs-keyword">pub</span> nid: <span class="hljs-type">u16</span>,
    <span class="hljs-keyword">pub</span> tsid: <span class="hljs-type">u16</span>,
    <span class="hljs-keyword">pub</span> sid: <span class="hljs-type">u16</span>,
    <span class="hljs-keyword">pub</span> display_name: <span class="hljs-type">String</span>, <span class="hljs-comment">// &quot;NHK総合&quot;, &quot;BS朝日&quot; など</span>
    <span class="hljs-keyword">pub</span> remote_key: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u8</span>&gt;,
}

<span class="hljs-comment">/// チャンネルリストからチューナー空間を自動生成</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SpaceBuilder</span> {
    <span class="hljs-comment">/// 生成されたSpace一覧</span>
    spaces: BTreeMap&lt;<span class="hljs-type">u32</span>, TuningSpace&gt;,
    <span class="hljs-comment">/// NID → Space ID マッピング</span>
    nid_to_space: HashMap&lt;<span class="hljs-type">u16</span>, <span class="hljs-type">u32</span>&gt;,
    <span class="hljs-comment">/// (space, channel) → (nid, tsid, sid) マッピング</span>
    physical_to_logical: HashMap&lt;(<span class="hljs-type">u32</span>, <span class="hljs-type">u32</span>), (<span class="hljs-type">u16</span>, <span class="hljs-type">u16</span>, <span class="hljs-type">u16</span>)&gt;,
    <span class="hljs-comment">/// 次のSpace ID</span>
    next_space_id: <span class="hljs-type">u32</span>,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">SpaceBuilder</span> {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">Self</span> {
            spaces: BTreeMap::<span class="hljs-title function_ invoke__">new</span>(),
            nid_to_space: HashMap::<span class="hljs-title function_ invoke__">new</span>(),
            physical_to_logical: HashMap::<span class="hljs-title function_ invoke__">new</span>(),
            next_space_id: <span class="hljs-number">0</span>,
        }
    }

    <span class="hljs-comment">/// チャンネルリストからSpace構造を構築</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">build_from_channels</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, channels: &amp;[ClientChannelInfo]) {
        <span class="hljs-comment">// 1. チャンネルをBroadcastType + Region でグループ化</span>
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">groups</span>: HashMap&lt;(BroadcastType, <span class="hljs-type">Option</span>&lt;TerrestrialRegion&gt;), <span class="hljs-type">Vec</span>&lt;&amp;ClientChannelInfo&gt;&gt;
            = HashMap::<span class="hljs-title function_ invoke__">new</span>();

        <span class="hljs-keyword">for</span> <span class="hljs-variable">ch</span> <span class="hljs-keyword">in</span> channels {
            <span class="hljs-keyword">let</span> (btype, region) = <span class="hljs-title function_ invoke__">classify_nid</span>(ch.nid);
            groups.<span class="hljs-title function_ invoke__">entry</span>((btype, region)).<span class="hljs-title function_ invoke__">or_default</span>().<span class="hljs-title function_ invoke__">push</span>(ch);
        }

        <span class="hljs-comment">// 2. 固定順序でSpaceを生成: 地デジ各地域 → BS → CS</span>
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ordered_keys</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = groups.<span class="hljs-title function_ invoke__">keys</span>().<span class="hljs-title function_ invoke__">cloned</span>().<span class="hljs-title function_ invoke__">collect</span>();
        ordered_keys.<span class="hljs-title function_ invoke__">sort_by</span>(|a, b| {
            <span class="hljs-comment">// 地デジ → BS → CS の順</span>
            <span class="hljs-keyword">let</span> <span class="hljs-variable">type_order</span> = |t: &amp;BroadcastType| <span class="hljs-keyword">match</span> t {
                BroadcastType::Terrestrial =&gt; <span class="hljs-number">0</span>,
                BroadcastType::BS =&gt; <span class="hljs-number">1</span>,
                BroadcastType::CS =&gt; <span class="hljs-number">2</span>,
            };
            <span class="hljs-title function_ invoke__">type_order</span>(&amp;a.<span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">cmp</span>(&amp;<span class="hljs-title function_ invoke__">type_order</span>(&amp;b.<span class="hljs-number">0</span>))
        });

        <span class="hljs-keyword">for</span> <span class="hljs-variable">key</span> <span class="hljs-keyword">in</span> ordered_keys {
            <span class="hljs-keyword">let</span> (btype, region) = key;
            <span class="hljs-keyword">let</span> <span class="hljs-variable">chs</span> = groups.<span class="hljs-title function_ invoke__">get</span>(&amp;key).<span class="hljs-title function_ invoke__">unwrap</span>();

            <span class="hljs-comment">// Space名を生成</span>
            <span class="hljs-keyword">let</span> <span class="hljs-variable">space_name</span> = <span class="hljs-keyword">match</span> btype {
                BroadcastType::Terrestrial =&gt; {
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(r) = region {
                        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;地デジ ({})&quot;</span>, r.<span class="hljs-title function_ invoke__">display_name</span>())
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-string">&quot;地デジ&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()
                    }
                }
                BroadcastType::BS =&gt; <span class="hljs-string">&quot;BS&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),
                BroadcastType::CS =&gt; <span class="hljs-string">&quot;CS&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),
            };

            <span class="hljs-keyword">let</span> <span class="hljs-variable">space_id</span> = <span class="hljs-keyword">self</span>.next_space_id;
            <span class="hljs-keyword">self</span>.next_space_id += <span class="hljs-number">1</span>;

            <span class="hljs-comment">// チャンネルをリモコンキー順 or SID順でソート</span>
            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">sorted_chs</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = chs.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">cloned</span>().<span class="hljs-title function_ invoke__">collect</span>();
            sorted_chs.<span class="hljs-title function_ invoke__">sort_by</span>(|a, b| {
                <span class="hljs-comment">// リモコンキーがあればそれで、なければSIDで</span>
                <span class="hljs-title function_ invoke__">match</span> (a.remote_control_key, b.remote_control_key) {
                    (<span class="hljs-title function_ invoke__">Some</span>(ka), <span class="hljs-title function_ invoke__">Some</span>(kb)) =&gt; ka.<span class="hljs-title function_ invoke__">cmp</span>(&amp;kb),
                    (<span class="hljs-title function_ invoke__">Some</span>(_), <span class="hljs-literal">None</span>) =&gt; std::cmp::Ordering::Less,
                    (<span class="hljs-literal">None</span>, <span class="hljs-title function_ invoke__">Some</span>(_)) =&gt; std::cmp::Ordering::Greater,
                    (<span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>) =&gt; a.sid.<span class="hljs-title function_ invoke__">cmp</span>(&amp;b.sid),
                }
            });

            <span class="hljs-comment">// SpaceChannelを生成</span>
            <span class="hljs-keyword">let</span> <span class="hljs-variable">space_channels</span>: <span class="hljs-type">Vec</span>&lt;SpaceChannel&gt; = sorted_chs
                .<span class="hljs-title function_ invoke__">iter</span>()
                .<span class="hljs-title function_ invoke__">enumerate</span>()
                .<span class="hljs-title function_ invoke__">map</span>(|(idx, ch)| {
                    <span class="hljs-comment">// マッピングを登録</span>
                    <span class="hljs-keyword">self</span>.physical_to_logical.<span class="hljs-title function_ invoke__">insert</span>(
                        (space_id, idx <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>),
                        (ch.nid, ch.tsid, ch.sid),
                    );

                    SpaceChannel {
                        index: idx <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>,
                        nid: ch.nid,
                        tsid: ch.tsid,
                        sid: ch.sid,
                        display_name: ch.channel_name.<span class="hljs-title function_ invoke__">clone</span>(),
                        remote_key: ch.remote_control_key,
                    }
                })
                .<span class="hljs-title function_ invoke__">collect</span>();

            <span class="hljs-comment">// NID → Space マッピング</span>
            <span class="hljs-keyword">for</span> <span class="hljs-variable">ch</span> <span class="hljs-keyword">in</span> &amp;sorted_chs {
                <span class="hljs-keyword">self</span>.nid_to_space.<span class="hljs-title function_ invoke__">insert</span>(ch.nid, space_id);
            }

            <span class="hljs-comment">// Spaceを登録</span>
            <span class="hljs-keyword">self</span>.spaces.<span class="hljs-title function_ invoke__">insert</span>(space_id, TuningSpace {
                space_id,
                name: space_name,
                broadcast_type: btype,
                region,
                channels: space_channels,
            });
        }
    }

    <span class="hljs-comment">/// Space数を取得</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">num_spaces</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> {
        <span class="hljs-keyword">self</span>.spaces.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>
    }

    <span class="hljs-comment">/// Space名を取得</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_space_name</span>(&amp;<span class="hljs-keyword">self</span>, space: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">str</span>&gt; {
        <span class="hljs-keyword">self</span>.spaces.<span class="hljs-title function_ invoke__">get</span>(&amp;space).<span class="hljs-title function_ invoke__">map</span>(|s| s.name.<span class="hljs-title function_ invoke__">as_str</span>())
    }

    <span class="hljs-comment">/// Space内のチャンネル数を取得</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">num_channels_in_space</span>(&amp;<span class="hljs-keyword">self</span>, space: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> {
        <span class="hljs-keyword">self</span>.spaces.<span class="hljs-title function_ invoke__">get</span>(&amp;space)
            .<span class="hljs-title function_ invoke__">map</span>(|s| s.channels.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>)
            .<span class="hljs-title function_ invoke__">unwrap_or</span>(<span class="hljs-number">0</span>)
    }

    <span class="hljs-comment">/// チャンネル名を取得</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_channel_name</span>(&amp;<span class="hljs-keyword">self</span>, space: <span class="hljs-type">u32</span>, channel: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">str</span>&gt; {
        <span class="hljs-keyword">self</span>.spaces.<span class="hljs-title function_ invoke__">get</span>(&amp;space)
            .<span class="hljs-title function_ invoke__">and_then</span>(|s| s.channels.<span class="hljs-title function_ invoke__">get</span>(channel <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>))
            .<span class="hljs-title function_ invoke__">map</span>(|c| c.display_name.<span class="hljs-title function_ invoke__">as_str</span>())
    }

    <span class="hljs-comment">/// (Space, Channel) → (NID, TSID, SID) 解決</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">resolve</span>(&amp;<span class="hljs-keyword">self</span>, space: <span class="hljs-type">u32</span>, channel: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;(<span class="hljs-type">u16</span>, <span class="hljs-type">u16</span>, <span class="hljs-type">u16</span>)&gt; {
        <span class="hljs-keyword">self</span>.physical_to_logical.<span class="hljs-title function_ invoke__">get</span>(&amp;(space, channel)).<span class="hljs-title function_ invoke__">copied</span>()
    }
}
</code></pre>
<p><strong>TVTest互換: EnumChannelName実装</strong>:</p>
<pre><code class="language-rust"><span class="hljs-comment">// bondriver-proxy-client/src/bondriver/exports.rs</span>

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">BonDriverProxy</span> {
    <span class="hljs-comment">/// チャンネルリスト受信時にSpace構造を自動構築</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">on_channel_list_received</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, channels: <span class="hljs-type">Vec</span>&lt;ClientChannelInfo&gt;) {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">builder</span> = SpaceBuilder::<span class="hljs-title function_ invoke__">new</span>();
        builder.<span class="hljs-title function_ invoke__">build_from_channels</span>(&amp;channels);
        <span class="hljs-keyword">self</span>.space_builder = builder;
    }

    <span class="hljs-comment">/// TVTest用: チューニング空間数</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">enum_tuning_space</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> {
        <span class="hljs-keyword">self</span>.space_builder.<span class="hljs-title function_ invoke__">num_spaces</span>()
    }

    <span class="hljs-comment">/// TVTest用: チューニング空間名</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">enum_tuning_space_name</span>(&amp;<span class="hljs-keyword">self</span>, space: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt; {
        <span class="hljs-keyword">self</span>.space_builder.<span class="hljs-title function_ invoke__">get_space_name</span>(space).<span class="hljs-title function_ invoke__">map</span>(|s| s.<span class="hljs-title function_ invoke__">to_string</span>())
    }

    <span class="hljs-comment">/// TVTest用: チャンネル数</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">enum_channel</span>(&amp;<span class="hljs-keyword">self</span>, space: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> {
        <span class="hljs-keyword">self</span>.space_builder.<span class="hljs-title function_ invoke__">num_channels_in_space</span>(space)
    }

    <span class="hljs-comment">/// TVTest用: チャンネル名列挙</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">enum_channel_name</span>(&amp;<span class="hljs-keyword">self</span>, space: <span class="hljs-type">u32</span>, index: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt; {
        <span class="hljs-keyword">self</span>.space_builder.<span class="hljs-title function_ invoke__">get_channel_name</span>(space, index).<span class="hljs-title function_ invoke__">map</span>(|s| s.<span class="hljs-title function_ invoke__">to_string</span>())
    }

    <span class="hljs-comment">/// TVTest用: チャンネル選択</span>
    <span class="hljs-comment">/// Space/Channel → NID/TSID/SID変換 → サーバーへ論理指定で要求</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_channel</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, space: <span class="hljs-type">u32</span>, channel: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> {
        <span class="hljs-comment">// Space/ChannelからNID-TSID-SIDを解決</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>((nid, tsid, sid)) = <span class="hljs-keyword">self</span>.space_builder.<span class="hljs-title function_ invoke__">resolve</span>(space, channel) {
            <span class="hljs-comment">// 論理指定でサーバーへ要求</span>
            <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">send_set_channel</span>(ChannelSelector::Logical {
                nid,
                tsid,
                sid: <span class="hljs-title function_ invoke__">Some</span>(sid),
            })
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 解決失敗: 物理指定でフォールバック</span>
            <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">send_set_channel</span>(ChannelSelector::Physical {
                tuner_id: <span class="hljs-keyword">self</span>.current_tuner.<span class="hljs-title function_ invoke__">clone</span>(),
                space,
                channel,
            })
        }
    }
}
</code></pre>
<p><strong>生成されるSpace構造の例</strong>:</p>
<pre><code>┌─────────────────────────────────────────────────────────────────────┐
│  自動生成されるチューナー空間（関東＋BS環境の例）                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Space 0: &quot;地デジ (関東)&quot;     ← NID=0x7FE8 のチャンネル             │
│    Channel 0: NHK総合          (NID=0x7FE8, SID=1024, リモコン1)    │
│    Channel 1: NHK Eテレ        (NID=0x7FE8, SID=1032, リモコン2)    │
│    Channel 2: 日本テレビ       (NID=0x7FE8, SID=1040, リモコン4)    │
│    Channel 3: テレビ朝日       (NID=0x7FE8, SID=1064, リモコン5)    │
│    Channel 4: TBS             (NID=0x7FE8, SID=1048, リモコン6)    │
│    Channel 5: テレビ東京       (NID=0x7FE8, SID=1072, リモコン7)    │
│    Channel 6: フジテレビ       (NID=0x7FE8, SID=1056, リモコン8)    │
│    ...                                                              │
│                                                                     │
│  Space 1: &quot;BS&quot;                ← NID=4 のチャンネル                  │
│    Channel 0: NHK BS1          (NID=4, SID=101, リモコン1)          │
│    Channel 1: NHK BSプレミアム  (NID=4, SID=103, リモコン3)          │
│    Channel 2: BS日テレ         (NID=4, SID=141, リモコン4)          │
│    Channel 3: BS朝日           (NID=4, SID=151, リモコン5)          │
│    Channel 4: BS-TBS           (NID=4, SID=161, リモコン6)          │
│    ...                                                              │
│                                                                     │
│  Space 2: &quot;CS&quot;                ← NID=6,7,10 のチャンネル             │
│    Channel 0: スカチャン1      (NID=6, SID=...)                     │
│    Channel 1: 映画チャンネル   (NID=7, SID=...)                     │
│    ...                                                              │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

複数地域が混在する場合:
┌─────────────────────────────────────────────────────────────────────┐
│  Space 0: &quot;地デジ (関東)&quot;     ← NID=0x7FE8                         │
│  Space 1: &quot;地デジ (近畿)&quot;     ← NID=0x7FE9                         │
│  Space 2: &quot;BS&quot;                                                      │
│  Space 3: &quot;CS&quot;                                                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h4 id="375-全体シーケンス">3.7.5 全体シーケンス</h4>
<pre><code>┌─────────────────────────────────────────────────────────────────────────────┐
│  TVTest起動 → チャンネル選択 シーケンス                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  TVTest              BonDriver DLL           Proxy Server         Database │
│    │                      │                       │                   │    │
│    │  CreateBonDriver()   │                       │                   │    │
│    │─────────────────────▶│                       │                   │    │
│    │                      │                       │                   │    │
│    │  OpenTuner()         │   Connect             │                   │    │
│    │─────────────────────▶│──────────────────────▶│                   │    │
│    │                      │                       │                   │    │
│    │                      │   ChannelList Request │                   │    │
│    │                      │──────────────────────▶│   Query           │    │
│    │                      │                       │──────────────────▶│    │
│    │                      │                       │◀──────────────────│    │
│    │                      │◀──────────────────────│   Channels        │    │
│    │                      │   ChannelList Response│                   │    │
│    │                      │   (Cache locally)     │                   │    │
│    │                      │                       │                   │    │
│    │  EnumTuningSpace()   │                       │                   │    │
│    │─────────────────────▶│  (from cache)         │                   │    │
│    │◀─────────────────────│                       │                   │    │
│    │                      │                       │                   │    │
│    │  EnumChannelName()   │                       │                   │    │
│    │─────────────────────▶│  (from cache)         │                   │    │
│    │◀─────────────────────│                       │                   │    │
│    │                      │                       │                   │    │
│    │  SetChannel(0, 5)    │                       │                   │    │
│    │─────────────────────▶│                       │                   │    │
│    │                      │   Resolve: (0,5)→NID/TSID/SID            │    │
│    │                      │                       │                   │    │
│    │                      │   SetChannel(Logical) │                   │    │
│    │                      │──────────────────────▶│                   │    │
│    │                      │                       │   Find best tuner │    │
│    │                      │                       │──────────────────▶│    │
│    │                      │                       │◀──────────────────│    │
│    │                      │                       │                   │    │
│    │                      │                       │   Acquire lock    │    │
│    │                      │                       │   Tune channel    │    │
│    │                      │                       │                   │    │
│    │                      │◀──────────────────────│   OK + StreamStart│    │
│    │◀─────────────────────│                       │                   │    │
│    │                      │                       │                   │    │
│    │  GetTsStream()       │◀══════════════════════│   TS Data         │    │
│    │◀─────────────────────│                       │                   │    │
│    │                      │                       │                   │    │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="38-プロトコルモジュール-recisdb-protocol">3.8 プロトコルモジュール (recisdb-protocol/)</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>名称</th>
<th>方向</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0001</td>
<td>OpenTuner</td>
<td>C→S</td>
<td>チューナーオープン要求</td>
</tr>
<tr>
<td>0x0002</td>
<td>CloseTuner</td>
<td>C→S</td>
<td>チューナークローズ</td>
</tr>
<tr>
<td>0x0010</td>
<td>ChannelListRequest</td>
<td>C→S</td>
<td>チャンネルリスト要求</td>
</tr>
<tr>
<td>0x0011</td>
<td>ChannelListResponse</td>
<td>S→C</td>
<td>チャンネルリスト応答</td>
</tr>
<tr>
<td>0x0012</td>
<td>ChannelListUpdate</td>
<td>S→C</td>
<td>チャンネルリスト差分更新</td>
</tr>
<tr>
<td>0x0101</td>
<td>SetChannelPhysical</td>
<td>C→S</td>
<td>物理指定チャンネル設定</td>
</tr>
<tr>
<td>0x0102</td>
<td>SetChannelLogical</td>
<td>C→S</td>
<td>論理指定チャンネル設定 (NID/TSID)</td>
</tr>
<tr>
<td>0x0301</td>
<td>GetSignalLevel</td>
<td>C→S</td>
<td>信号レベル取得</td>
</tr>
<tr>
<td>0x0401</td>
<td>StartStream</td>
<td>C→S</td>
<td>ストリーム開始</td>
</tr>
<tr>
<td>0x0403</td>
<td>StreamData</td>
<td>S→C</td>
<td>TSデータ送信</td>
</tr>
</tbody>
</table>
<p><strong>フレームフォーマット</strong>:</p>
<pre><code class="language-rust"><span class="hljs-comment">// recisdb-protocol/src/codec.rs</span>
<span class="hljs-meta">#[derive(Debug, Clone)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Frame</span> {
    <span class="hljs-keyword">pub</span> magic: [<span class="hljs-type">u8</span>; <span class="hljs-number">4</span>],      <span class="hljs-comment">// &quot;BNDP&quot;</span>
    <span class="hljs-keyword">pub</span> length: <span class="hljs-type">u32</span>,         <span class="hljs-comment">// LE</span>
    <span class="hljs-keyword">pub</span> message_type: <span class="hljs-type">u16</span>,   <span class="hljs-comment">// LE</span>
    <span class="hljs-keyword">pub</span> payload: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;,
}
</code></pre>
<h3 id="34-プロキシサーバー-recisdb-proxy">3.4 プロキシサーバー (recisdb-proxy/)</h3>
<p><strong>TunerPool設計</strong>:</p>
<pre><code class="language-rust"><span class="hljs-comment">// recisdb-proxy/src/tuner/pool.rs</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TunerPool</span> {
    tuners: RwLock&lt;HashMap&lt;ChannelKey, Arc&lt;SharedTuner&gt;&gt;&gt;,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">TunerPool</span> {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_or_create</span>(
        &amp;<span class="hljs-keyword">self</span>,
        tuner_path: &amp;<span class="hljs-type">str</span>,
        channel: &amp;Channel,
    ) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;Arc&lt;SharedTuner&gt;&gt; {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">key</span> = ChannelKey::<span class="hljs-title function_ invoke__">from</span>(tuner_path, channel);
        
        <span class="hljs-comment">// 既存チューナー再利用</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(tuner) = <span class="hljs-keyword">self</span>.tuners.<span class="hljs-title function_ invoke__">read</span>().<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">get</span>(&amp;key) {
            <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(Arc::<span class="hljs-title function_ invoke__">clone</span>(tuner));
        }
        
        <span class="hljs-comment">// 新規作成</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">shared</span> = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">create_tuner</span>(tuner_path, channel).<span class="hljs-keyword">await</span>?;
        <span class="hljs-keyword">self</span>.tuners.<span class="hljs-title function_ invoke__">write</span>().<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">insert</span>(key, Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;shared));
        <span class="hljs-title function_ invoke__">Ok</span>(shared)
    }
}
</code></pre>
<p><strong>セッション管理</strong>:</p>
<ul>
<li>TCP/TLSリスナー（tokio-rustls）</li>
<li>クライアント認証（証明書ベース）</li>
<li>セッションごとのチャンネル共有</li>
</ul>
<h3 id="35-クライアントdll-bondriver-proxy-client">3.5 クライアントDLL (bondriver-proxy-client/)</h3>
<p><strong>IBonDriver vtable実装</strong>:</p>
<pre><code class="language-rust"><span class="hljs-comment">// bondriver-proxy-client/src/bondriver/interface.rs</span>
<span class="hljs-meta">#[repr(C)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">IBonDriver1</span> {
    <span class="hljs-keyword">pub</span> vtable: *<span class="hljs-keyword">const</span> IBonDriver1VTable,
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-meta">#[repr(C)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">IBonDriver1VTable</span> {
    <span class="hljs-keyword">pub</span> OpenTuner: <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-title function_ invoke__">fn</span>(*<span class="hljs-keyword">mut</span> IBonDriver1) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>,
    <span class="hljs-keyword">pub</span> CloseTuner: <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-title function_ invoke__">fn</span>(*<span class="hljs-keyword">mut</span> IBonDriver1),
    <span class="hljs-keyword">pub</span> SetChannel: <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-title function_ invoke__">fn</span>(*<span class="hljs-keyword">mut</span> IBonDriver1, space: <span class="hljs-type">u32</span>, channel: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>,
    <span class="hljs-keyword">pub</span> GetTsStream: <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-title function_ invoke__">fn</span>(
        *<span class="hljs-keyword">mut</span> IBonDriver1,
        *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>,
        *<span class="hljs-keyword">mut</span> <span class="hljs-type">u32</span>,
        *<span class="hljs-keyword">mut</span> <span class="hljs-type">u32</span>,
    ) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>,
    <span class="hljs-comment">// ... v2, v3</span>
}
</code></pre>
<p><strong>リングバッファ</strong>:</p>
<pre><code class="language-rust"><span class="hljs-comment">// bondriver-proxy-client/src/client/buffer.rs</span>
<span class="hljs-keyword">const</span> RING_BUFFER_SIZE: <span class="hljs-type">usize</span> = <span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>; <span class="hljs-comment">// 2MB</span>

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TsRingBuffer</span> {
    buffer: <span class="hljs-type">Box</span>&lt;[<span class="hljs-type">u8</span>; RING_BUFFER_SIZE]&gt;,
    write_pos: AtomicUsize,  <span class="hljs-comment">// Receiver Task</span>
    read_pos: AtomicUsize,   <span class="hljs-comment">// Main Thread (GetTsStream)</span>
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">TsRingBuffer</span> {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">self</span>, data: &amp;[<span class="hljs-type">u8</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">usize</span>&gt; {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">write</span> = <span class="hljs-keyword">self</span>.write_pos.<span class="hljs-title function_ invoke__">load</span>(Ordering::Acquire);
        <span class="hljs-keyword">let</span> <span class="hljs-variable">read</span> = <span class="hljs-keyword">self</span>.read_pos.<span class="hljs-title function_ invoke__">load</span>(Ordering::Acquire);
        <span class="hljs-comment">// ロックフリー実装</span>
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<hr>
<h2 id="4-cliコマンド拡張">4. CLIコマンド拡張</h2>
<h3 id="41-新コマンド定義">4.1 新コマンド定義</h3>
<p><strong>変更ファイル</strong>: <code>recisdb-rs/src/context.rs</code></p>
<pre><code class="language-rust"><span class="hljs-meta">#[derive(Parser, Debug)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Commands</span> {
    <span class="hljs-comment">// 既存コマンド</span>
    <span class="hljs-meta">#[clap(name = <span class="hljs-string">&quot;tune&quot;</span>)]</span>
    Tune { <span class="hljs-comment">/* ... */</span> },
    
    <span class="hljs-meta">#[clap(name = <span class="hljs-string">&quot;decode&quot;</span>)]</span>
    Decode { <span class="hljs-comment">/* ... */</span> },
    
    <span class="hljs-meta">#[clap(name = <span class="hljs-string">&quot;enumerate&quot;</span>)]</span>
    Enumerate { <span class="hljs-comment">/* ... */</span> },
    
    <span class="hljs-meta">#[clap(name = <span class="hljs-string">&quot;checksignal&quot;</span>)]</span>
    CheckSignal { <span class="hljs-comment">/* ... */</span> },
    
    <span class="hljs-comment">// **新規コマンド**: チャンネルスキャン</span>
    <span class="hljs-meta">#[clap(name = <span class="hljs-string">&quot;scan&quot;</span>)]</span>
    Scan {
        <span class="hljs-comment">/// BonDriver DLL path</span>
        <span class="hljs-meta">#[clap(short, long)]</span>
        device: <span class="hljs-type">String</span>,
        
        <span class="hljs-comment">/// Output database file path</span>
        <span class="hljs-meta">#[clap(short, long)]</span>
        database: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,
        
        <span class="hljs-comment">/// Recreate database from scratch</span>
        <span class="hljs-meta">#[clap(short, long)]</span>
        recreate: <span class="hljs-type">bool</span>,
        
        <span class="hljs-comment">/// Timeout in seconds</span>
        <span class="hljs-meta">#[clap(short, long, default_value = <span class="hljs-string">&quot;30&quot;</span>)]</span>
        timeout: <span class="hljs-type">u64</span>,
    },
    
    <span class="hljs-comment">// **新規コマンド**: チャンネル表示</span>
    <span class="hljs-meta">#[clap(name = <span class="hljs-string">&quot;show&quot;</span>)]</span>
    Show {
        <span class="hljs-comment">/// BonDriver DLL path</span>
        <span class="hljs-meta">#[clap(short, long)]</span>
        device: <span class="hljs-type">String</span>,
        
        <span class="hljs-comment">/// Database file path</span>
        <span class="hljs-meta">#[clap(short, long)]</span>
        database: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,
        
        <span class="hljs-comment">/// Output format (json/table)</span>
        <span class="hljs-meta">#[clap(short, long, default_value = <span class="hljs-string">&quot;table&quot;</span>)]</span>
        format: <span class="hljs-type">String</span>,
    },
    
    <span class="hljs-comment">// **新規コマンド**: チャンネルクエリ</span>
    <span class="hljs-meta">#[clap(name = <span class="hljs-string">&quot;query&quot;</span>)]</span>
    Query {
        <span class="hljs-comment">/// BonDriver DLL path</span>
        <span class="hljs-meta">#[clap(short, long)]</span>
        device: <span class="hljs-type">String</span>,
        
        <span class="hljs-comment">/// Database file path</span>
        <span class="hljs-meta">#[clap(short, long)]</span>
        database: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,
        
        <span class="hljs-comment">/// Channel to query (e.g., BS101, CS110_1)</span>
        <span class="hljs-meta">#[clap(short, long)]</span>
        channel: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,
        
        <span class="hljs-comment">/// NID to query</span>
        <span class="hljs-meta">#[clap(short, long)]</span>
        nid: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u16</span>&gt;,
        
        <span class="hljs-comment">/// SID to query</span>
        <span class="hljs-meta">#[clap(short, long)]</span>
        sid: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u16</span>&gt;,
        
        <span class="hljs-comment">/// TSID to query</span>
        <span class="hljs-meta">#[clap(short, long)]</span>
        tsid: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u16</span>&gt;,
        
        <span class="hljs-comment">/// Manual sheet number</span>
        <span class="hljs-meta">#[clap(short, long)]</span>
        manual_sheet: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u16</span>&gt;,
    },
}
</code></pre>
<h3 id="42-コマンド実装">4.2 コマンド実装</h3>
<p><strong>scanコマンド</strong> (<code>recisdb-rs/src/commands/scan.rs</code>):</p>
<p><strong>スキャンフロー図</strong>:</p>
<pre><code>┌─────────────────────────────────────────────────────────────────────┐
│  BonDriver自動チャンネルスキャン フロー                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. BonDriver初期化                                                 │
│     └── OpenTuner() → EnumTuningSpace() → EnumChannelName()        │
│                                                                     │
│  2. Space/Channel全走査                                             │
│     ┌────────────────────────────────────────────────────────┐      │
│     │  for space in 0..num_spaces:                           │      │
│     │    for ch in 0..num_channels[space]:                   │      │
│     │      SetChannel(space, ch)                             │      │
│     │      wait_for_lock(timeout)                            │      │
│     │      if signal_level &gt; threshold:                      │      │
│     │        collect_ts_packets(duration)                    │      │
│     │        analyze_pat_sdt_nit()                           │      │
│     │        store_channel_info()                            │      │
│     └────────────────────────────────────────────────────────┘      │
│                                                                     │
│  3. DB更新                                                          │
│     └── merge_scan_results() → 新規INSERT/既存UPDATE/消失無効化     │
│                                                                     │
│  4. 結果出力                                                        │
│     └── inserted: N, updated: M, disabled: K                       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<pre><code class="language-rust"><span class="hljs-keyword">use</span> std::time::{Duration, Instant};
<span class="hljs-keyword">use</span> crate::database::Database;
<span class="hljs-keyword">use</span> crate::ts_analyzer::TsAnalyzer;
<span class="hljs-keyword">use</span> crate::tuner::windows::UnTunedTuner;

<span class="hljs-keyword">const</span> TS_PACKET_SIZE: <span class="hljs-type">usize</span> = <span class="hljs-number">188</span>;
<span class="hljs-keyword">const</span> SIGNAL_THRESHOLD: <span class="hljs-type">f64</span> = <span class="hljs-number">5.0</span>;
<span class="hljs-keyword">const</span> ANALYSIS_DURATION_MS: <span class="hljs-type">u64</span> = <span class="hljs-number">2000</span>;

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">scan_bon_driver</span>(
    device: &amp;<span class="hljs-type">str</span>,
    db_path: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">str</span>&gt;,
    recreate: <span class="hljs-type">bool</span>,
    timeout_secs: <span class="hljs-type">u64</span>,
) <span class="hljs-punctuation">-&gt;</span> std::io::<span class="hljs-type">Result</span>&lt;ScanResult&gt; {
    <span class="hljs-comment">// Database setup</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">default_db</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;{}.sqlite&quot;</span>, device.<span class="hljs-title function_ invoke__">replace</span>(<span class="hljs-string">&quot;.dll&quot;</span>, <span class="hljs-string">&quot;&quot;</span>));
    <span class="hljs-keyword">let</span> <span class="hljs-variable">db_path</span> = db_path.<span class="hljs-title function_ invoke__">unwrap_or</span>(&amp;default_db);

    <span class="hljs-keyword">if</span> recreate {
        std::fs::<span class="hljs-title function_ invoke__">remove_file</span>(db_path).<span class="hljs-title function_ invoke__">ok</span>();
    }

    <span class="hljs-keyword">let</span> <span class="hljs-variable">db</span> = Database::<span class="hljs-title function_ invoke__">new</span>(db_path)?;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">bon_driver_id</span> = db.<span class="hljs-title function_ invoke__">get_or_create_bon_driver</span>(device)?;
    info!(<span class="hljs-string">&quot;Database: {}, BonDriver ID: {}&quot;</span>, db_path, bon_driver_id);

    <span class="hljs-comment">// Open tuner</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">tuner</span> = UnTunedTuner::<span class="hljs-title function_ invoke__">new</span>(device.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-number">200000</span>)?;
    info!(<span class="hljs-string">&quot;Opened BonDriver: {}&quot;</span>, device);

    <span class="hljs-comment">// Get available spaces and channels</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">num_spaces</span> = tuner.<span class="hljs-title function_ invoke__">enum_tuning_space</span>().<span class="hljs-title function_ invoke__">unwrap_or</span>(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scanned_channels</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();

    <span class="hljs-keyword">for</span> <span class="hljs-variable">space</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..num_spaces {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">channel_names</span> = tuner.<span class="hljs-title function_ invoke__">enum_channels</span>(space);
        <span class="hljs-keyword">let</span> <span class="hljs-variable">num_channels</span> = channel_names.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">map</span>(|c| c.<span class="hljs-title function_ invoke__">len</span>()).<span class="hljs-title function_ invoke__">unwrap_or</span>(<span class="hljs-number">0</span>);

        info!(<span class="hljs-string">&quot;Space {}: {} channels&quot;</span>, space, num_channels);

        <span class="hljs-keyword">for</span> <span class="hljs-variable">ch</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..num_channels {
            <span class="hljs-comment">// Set channel</span>
            <span class="hljs-keyword">if</span> !tuner.<span class="hljs-title function_ invoke__">set_channel</span>(space, ch <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>) {
                warn!(<span class="hljs-string">&quot;Failed to set channel: space={}, ch={}&quot;</span>, space, ch);
                <span class="hljs-keyword">continue</span>;
            }

            <span class="hljs-comment">// Wait for lock and check signal</span>
            tokio::time::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">500</span>)).<span class="hljs-keyword">await</span>;
            <span class="hljs-keyword">let</span> <span class="hljs-variable">signal</span> = tuner.<span class="hljs-title function_ invoke__">get_signal_level</span>();

            <span class="hljs-keyword">if</span> signal &lt; SIGNAL_THRESHOLD {
                debug!(<span class="hljs-string">&quot;Low signal: space={}, ch={}, signal={:.1}&quot;</span>, space, ch, signal);
                <span class="hljs-keyword">continue</span>;
            }

            <span class="hljs-comment">// Analyze TS stream</span>
            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">analyzer</span> = TsAnalyzer::<span class="hljs-title function_ invoke__">new</span>();
            <span class="hljs-keyword">let</span> <span class="hljs-variable">start</span> = Instant::<span class="hljs-title function_ invoke__">now</span>();
            <span class="hljs-keyword">let</span> <span class="hljs-variable">timeout</span> = Duration::<span class="hljs-title function_ invoke__">from_millis</span>(ANALYSIS_DURATION_MS);

            <span class="hljs-keyword">while</span> start.<span class="hljs-title function_ invoke__">elapsed</span>() &lt; timeout &amp;&amp; !analyzer.<span class="hljs-title function_ invoke__">is_complete</span>() {
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(packet) = tuner.<span class="hljs-title function_ invoke__">read_packet</span>().<span class="hljs-keyword">await</span>? {
                    analyzer.<span class="hljs-title function_ invoke__">feed</span>(&amp;packet)?;
                }
            }

            <span class="hljs-comment">// Extract channel info</span>
            <span class="hljs-keyword">for</span> <span class="hljs-title class_">mut</span> channel_info <span class="hljs-keyword">in</span> analyzer.<span class="hljs-title function_ invoke__">extract_channels</span>() {
                <span class="hljs-comment">// BonDriver固有情報を記録</span>
                channel_info.bon_space = <span class="hljs-title function_ invoke__">Some</span>(space);
                channel_info.bon_channel = <span class="hljs-title function_ invoke__">Some</span>(ch <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>);

                info!(<span class="hljs-string">&quot;Found: NID={}, SID={}, TSID={}, name={:?}&quot;</span>,
                    channel_info.nid, channel_info.sid, channel_info.tsid,
                    channel_info.channel_name);

                scanned_channels.<span class="hljs-title function_ invoke__">push</span>(channel_info);
            }
        }
    }

    <span class="hljs-comment">// Merge results to database</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">merge_result</span> = db.<span class="hljs-title function_ invoke__">merge_scan_results</span>(bon_driver_id, &amp;scanned_channels)?;
    db.<span class="hljs-title function_ invoke__">update_scan_history</span>(bon_driver_id, scanned_channels.<span class="hljs-title function_ invoke__">len</span>(), <span class="hljs-literal">true</span>, <span class="hljs-literal">None</span>)?;

    info!(<span class="hljs-string">&quot;Scan complete: inserted={}, updated={}, disabled={}&quot;</span>,
        merge_result.inserted, merge_result.updated, merge_result.disabled);

    <span class="hljs-title function_ invoke__">Ok</span>(ScanResult {
        bon_driver_id,
        total_scanned: scanned_channels.<span class="hljs-title function_ invoke__">len</span>(),
        merge_result,
    })
}

<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ScanResult</span> {
    <span class="hljs-keyword">pub</span> bon_driver_id: <span class="hljs-type">i64</span>,
    <span class="hljs-keyword">pub</span> total_scanned: <span class="hljs-type">usize</span>,
    <span class="hljs-keyword">pub</span> merge_result: MergeResult,
}
</code></pre>
<p><strong>showコマンド</strong> (<code>recisdb-rs/src/commands/show.rs</code>):</p>
<pre><code class="language-rust"><span class="hljs-keyword">use</span> prettytable::{Table, Row, Cell};
<span class="hljs-keyword">use</span> serde_json;
<span class="hljs-keyword">use</span> crate::database::Database;

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">show_channels</span>(
    db_path: &amp;<span class="hljs-type">str</span>,
    dll_path: &amp;<span class="hljs-type">str</span>,
    format: &amp;<span class="hljs-type">str</span>,
) <span class="hljs-punctuation">-&gt;</span> std::io::<span class="hljs-type">Result</span>&lt;()&gt; {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">db</span> = Database::<span class="hljs-title function_ invoke__">new</span>(db_path)?;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">bon_driver_id</span> = db.<span class="hljs-title function_ invoke__">get_bon_driver_id</span>(dll_path)?.<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-variable">channels</span> = db.<span class="hljs-title function_ invoke__">get_channels_by_bon_driver</span>(bon_driver_id)?;
    
    <span class="hljs-keyword">if</span> format == <span class="hljs-string">&quot;json&quot;</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = serde_json::<span class="hljs-title function_ invoke__">to_string_pretty</span>(&amp;channels)?;
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, json);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">table</span> = Table::<span class="hljs-title function_ invoke__">new</span>();
        <span class="hljs-comment">// ... pretty table formatting</span>
        table.<span class="hljs-title function_ invoke__">printstd</span>();
    }
    
    <span class="hljs-title function_ invoke__">Ok</span>(())
}
</code></pre>
<hr>
<h2 id="5-tls認証設計">5. TLS認証設計</h2>
<h3 id="51-証明書構成">5.1 証明書構成</h3>
<pre><code>certs/
├── ca.crt              # CA証明書
├── server.crt          # サーバー証明書
├── server.key          # サーバー秘密鍵
├── client.crt          # クライアント証明書
└── client.key          # クライアント秘密鍵
</code></pre>
<h3 id="52-サーバー設定">5.2 サーバー設定</h3>
<pre><code class="language-toml"><span class="hljs-comment"># recisdb-proxy/recisdb-proxy.toml.example</span>
<span class="hljs-section">[tls]</span>
<span class="hljs-attr">enabled</span> = <span class="hljs-literal">true</span>
<span class="hljs-attr">ca_cert</span> = <span class="hljs-string">&quot;/etc/recisdb-proxy/certs/ca.crt&quot;</span>
<span class="hljs-attr">server_cert</span> = <span class="hljs-string">&quot;/etc/recisdb-proxy/certs/server.crt&quot;</span>
<span class="hljs-attr">server_key</span> = <span class="hljs-string">&quot;/etc/recisdb-proxy/certs/server.key&quot;</span>
<span class="hljs-attr">require_client_cert</span> = <span class="hljs-literal">true</span>
</code></pre>
<h3 id="53-クライアント設定">5.3 クライアント設定</h3>
<pre><code class="language-ini"><span class="hljs-comment">; BonDriver_NetworkProxy.ini</span>
<span class="hljs-section">[TLS]</span>
<span class="hljs-attr">Enabled</span>=<span class="hljs-number">1</span>
<span class="hljs-attr">CaCert</span>=ca.crt
<span class="hljs-attr">ClientCert</span>=client.crt
<span class="hljs-attr">ClientKey</span>=client.key

<span class="hljs-section">[Server]</span>
<span class="hljs-attr">Address</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">1.100</span>
<span class="hljs-attr">Port</span>=<span class="hljs-number">12345</span>
</code></pre>
<hr>
<h2 id="6-設定ファイル構造">6. 設定ファイル構造</h2>
<h3 id="61-recisdb-rs-設定">6.1 recisdb-rs 設定</h3>
<pre><code class="language-toml"><span class="hljs-comment"># ~/.config/recisdb/config.toml</span>
<span class="hljs-section">[database]</span>
<span class="hljs-attr">path</span> = <span class="hljs-string">&quot;~/.local/share/recisdb/channels.sqlite&quot;</span>
<span class="hljs-attr">auto_backup</span> = <span class="hljs-literal">true</span>

<span class="hljs-section">[scan]</span>
<span class="hljs-attr">timeout</span> = <span class="hljs-number">30</span>
<span class="hljs-attr">retry_count</span> = <span class="hljs-number">3</span>
</code></pre>
<h3 id="62-recisdb-proxy-サーバー設定">6.2 recisdb-proxy サーバー設定</h3>
<pre><code class="language-toml"><span class="hljs-comment"># /etc/recisdb-proxy/config.toml</span>
<span class="hljs-section">[server]</span>
<span class="hljs-attr">listen</span> = <span class="hljs-string">&quot;0.0.0.0:12345&quot;</span>
<span class="hljs-attr">max_connections</span> = <span class="hljs-number">10</span>

<span class="hljs-section">[tuner]</span>
<span class="hljs-attr">device</span> = <span class="hljs-string">&quot;/dev/pt3video0&quot;</span>
<span class="hljs-attr">pool_size</span> = <span class="hljs-number">4</span>

<span class="hljs-section">[tls]</span>
<span class="hljs-attr">enabled</span> = <span class="hljs-literal">true</span>
<span class="hljs-attr">ca_cert</span> = <span class="hljs-string">&quot;/etc/recisdb-proxy/certs/ca.crt&quot;</span>
<span class="hljs-attr">server_cert</span> = <span class="hljs-string">&quot;/etc/recisdb-proxy/certs/server.crt&quot;</span>
<span class="hljs-attr">server_key</span> = <span class="hljs-string">&quot;/etc/recisdb-proxy/certs/server.key&quot;</span>
<span class="hljs-attr">require_client_cert</span> = <span class="hljs-literal">true</span>
</code></pre>
<hr>
<h2 id="7-実装フェーズ">7. 実装フェーズ</h2>
<h3 id="phase-0-プロジェクト構成準備1週間">Phase 0: プロジェクト構成準備（1週間）</h3>
<ul class="contains-task-list">
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> 新規crate作成 (<code>recisdb-protocol</code>, <code>recisdb-proxy</code>, <code>bondriver-proxy-client</code>)</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> ワークスペース設定更新 (<code>Cargo.toml</code>)</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> 依存関係のバージョン調整</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> 既存コードのバックアップ</li>
</ul>
<h3 id="phase-1-データベース基盤2週間--完了">Phase 1: データベース基盤（2週間） ✅ 完了</h3>
<ul class="contains-task-list">
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> <code>recisdb-rs/src/database/</code> 作成</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> SQLiteスキーマ設計（AutoScan計画を基に改良）</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> モデル定義（<code>rusqlite</code> + <code>recisdb-protocol</code>）</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> 基本CRUD操作実装</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> <code>merge_scan_results()</code> - スキャン結果マージ</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> <code>passive_update_channels()</code> - パッシブスキャン更新</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> ユニットテスト</li>
</ul>
<p><strong>実装ファイル</strong>:</p>
<ul>
<li><code>mod.rs</code> - Database構造体、エラー型</li>
<li><code>schema.rs</code> - SQLスキーマ（bon_drivers, channels, scan_history）</li>
<li><code>models.rs</code> - BonDriverRecord, ChannelRecord, MergeResult</li>
<li><code>bon_driver.rs</code> - BonDriver CRUD + スキャン設定</li>
<li><code>channel.rs</code> - Channel CRUD + merge + passive update</li>
</ul>
<p><strong>成果物</strong>:</p>
<ul>
<li>データベースモジュール ✅</li>
<li>ユニットテスト ✅</li>
</ul>
<h3 id="phase-2-ts解析モジュール3週間">Phase 2: TS解析モジュール（3週間）</h3>
<ul class="contains-task-list">
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> <code>ts_analyzer</code> モジュール実装（PAT/PMT解析）</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> <code>ts_extractor</code> モジュール実装（NID/SID/TSID抽出）</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> プラットフォーム差異吸収（feature-gated）</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> シミュレーションモード（テスト用）</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> ユニットテスト</li>
</ul>
<p><strong>成果物</strong>:</p>
<ul>
<li>TS解析モジュール</li>
<li>テスト用シミュレータ</li>
<li>解析アルゴリズムドキュメント</li>
</ul>
<h3 id="phase-3-クライアントcli拡張2週間">Phase 3: クライアントCLI拡張（2週間）</h3>
<ul class="contains-task-list">
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> <code>scan</code> コマンド実装</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> <code>show</code> / <code>query</code> コマンド実装</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> <code>tune</code> コマンドにDB-backedオプション追加</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> データベース-backed <code>ChannelType</code> 統合</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> 統合テスト</li>
</ul>
<p><strong>成果物</strong>:</p>
<ul>
<li>CLIコマンド拡張</li>
<li>統合テスト</li>
<li>使い方ドキュメント</li>
</ul>
<h3 id="phase-4-プロトコル基盤1週間--完了">Phase 4: プロトコル基盤（1週間） ✅ 完了</h3>
<ul class="contains-task-list">
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> <code>recisdb-protocol</code> クレート作成</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> メッセージ型定義（AutoScan/Proxy共用）</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> バイナリコーデック実装</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> ユニットテスト（18件 + doctest 4件 パス）</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> <code>ChannelInfo</code>, <code>ChannelSelector</code> 型追加</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> <code>broadcast_region.rs</code> - NID→放送種別・地域判定</li>
</ul>
<p><strong>成果物</strong>:</p>
<ul>
<li>プロトコル定義 ✅</li>
<li>コーデック実装 ✅</li>
<li>チャンネル管理型 ✅</li>
<li>放送地域判定モジュール ✅</li>
</ul>
<h3 id="phase-5-プロキシサーバー3週間--進行中">Phase 5: プロキシサーバー（3週間） 🔄 進行中</h3>
<ul class="contains-task-list">
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> <code>recisdb-proxy</code> クレート作成</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> TCP/TLSリスナー実装（基盤）</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> <code>TunerPool</code> とチャンネル共有ロジック</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> <code>tuner/lock.rs</code> - 排他/共有ロック機構</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> <code>tuner/selector.rs</code> - フォールバック付きチューナー選択</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" checked=""type="checkbox"> <code>tuner/shared.rs</code> - 信号レベル・パケット追跡機能追加</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> セッション管理（プロトコル統合）</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> データベース統合</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> 統合テスト</li>
</ul>
<p><strong>実装ファイル</strong>:</p>
<ul>
<li><code>tuner/lock.rs</code> - TunerLock, ExclusiveLockGuard, SharedLockGuard</li>
<li><code>tuner/selector.rs</code> - TunerSelector, ChannelCandidate, FallbackResult</li>
<li><code>tuner/shared.rs</code> - lock(), get_signal_level(), has_received_packets()</li>
<li><code>tuner/mod.rs</code> - 新モジュールのエクスポート</li>
</ul>
<p><strong>成果物</strong>:</p>
<ul>
<li>サーバー基盤 ✅</li>
<li>チューナーロック機構 ✅</li>
<li>フォールバック選択 ✅</li>
<li>ユニットテスト（11件パス） ✅</li>
<li>チャンネル共有機能（部分）</li>
<li>統合テスト（e2e）</li>
</ul>
<h3 id="phase-6-クライアントdll3週間">Phase 6: クライアントDLL（3週間）</h3>
<ul class="contains-task-list">
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> <code>bondriver-proxy-client</code> クレート作成</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> IBonDriver vtable実装（v1/v2/v3）</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> リングバッファ実装（2MB, lock-free）</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> TCPクライアント（tokio）</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> TLS認証</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> DLLビルド設定</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> TVTest動作確認</li>
</ul>
<p><strong>成果物</strong>:</p>
<ul>
<li>BonDriver互換DLL</li>
<li>リングバッファ実装</li>
<li>TVTest動作確認結果</li>
</ul>
<h3 id="phase-7-統合最適化2週間">Phase 7: 統合・最適化（2週間）</h3>
<ul class="contains-task-list">
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> 全機能統合テスト</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> パフォーマンス最適化</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> ドキュメント更新</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> 設定ファイルサンプル作成</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox"type="checkbox"> CI/CD設定更新</li>
</ul>
<p><strong>成果物</strong>:</p>
<ul>
<li>完全統合システム</li>
<li>性能レポート</li>
<li>最終ドキュメント</li>
</ul>
<hr>
<h2 id="8-テスト戦略">8. テスト戦略</h2>
<h3 id="81-ユニットテスト">8.1 ユニットテスト</h3>
<ul>
<li><strong>データベース</strong>: モックを使用したCRUD操作テスト</li>
<li><strong>TS解析</strong>: パケットシミュレーションによる解析テスト</li>
<li><strong>プロトコル</strong>: コーデック単体テスト</li>
</ul>
<h3 id="82-インテグレーションテスト">8.2 インテグレーションテスト</h3>
<ul>
<li><strong>シシミュレーション環境</strong>: TSパケット生成によるスキャンテスト</li>
<li><strong>TCPプロキシ</strong>: エンドツーエンドテスト</li>
<li><strong>TLS認証</strong>: 証明書検証テスト</li>
</ul>
<h3 id="83-手動テスト">8.3 手動テスト</h3>
<ul>
<li><strong>実HW</strong>: Linux/Windowsでのスキャンテスト</li>
<li><strong>TVTest</strong>: プロキシDLLの動作確認</li>
<li><strong>負荷テスト</strong>: 複数クライアント同時接続</li>
</ul>
<h3 id="84-テストコマンド例">8.4 テストコマンド例</h3>
<pre><code class="language-bash"><span class="hljs-comment"># TS解析テスト（シミュレーション）</span>
cargo <span class="hljs-built_in">test</span> --features ts-analyzer ts_analyzer::

<span class="hljs-comment"># データベーステスト</span>
cargo <span class="hljs-built_in">test</span> --features database database::

<span class="hljs-comment"># 統合テスト（シミュレーション環境）</span>
cargo <span class="hljs-built_in">test</span> --features ts-analyzer,database integration::
</code></pre>
<hr>
<h2 id="9-依存関係管理">9. 依存関係管理</h2>
<h3 id="91-ワークスペース-cargotoml">9.1 ワークスペース Cargo.toml</h3>
<pre><code class="language-toml"><span class="hljs-section">[workspace]</span>
<span class="hljs-attr">members</span> = [
    <span class="hljs-string">&quot;b25-sys&quot;</span>,
    <span class="hljs-string">&quot;recisdb-rs&quot;</span>,
    <span class="hljs-string">&quot;recisdb-protocol&quot;</span>,
    <span class="hljs-string">&quot;recisdb-proxy&quot;</span>,
    <span class="hljs-string">&quot;bondriver-proxy-client&quot;</span>,
]

<span class="hljs-section">[workspace.dependencies]</span>
<span class="hljs-comment"># 共通依存</span>
<span class="hljs-attr">tokio</span> = { version = <span class="hljs-string">&quot;1&quot;</span>, features = [<span class="hljs-string">&quot;full&quot;</span>] }
<span class="hljs-attr">tokio-rustls</span> = <span class="hljs-string">&quot;0.25&quot;</span>
<span class="hljs-attr">rustls</span> = <span class="hljs-string">&quot;0.22&quot;</span>
<span class="hljs-attr">serde</span> = { version = <span class="hljs-string">&quot;1.0&quot;</span>, features = [<span class="hljs-string">&quot;derive&quot;</span>] }

<span class="hljs-comment"># 特定crate用</span>
<span class="hljs-attr">rusqlite</span> = { version = <span class="hljs-string">&quot;0.31&quot;</span>, features = [<span class="hljs-string">&quot;bundled&quot;</span>] }
<span class="hljs-attr">bitstream-io</span> = <span class="hljs-string">&quot;0.2&quot;</span>
</code></pre>
<h3 id="92-既存依存関係の維持">9.2 既存依存関係の維持</h3>
<ul>
<li><code>futures-util</code> → 継続使用（非同期I/O）</li>
<li><code>nom</code> → 継続使用（チャネルパーサー）</li>
<li><code>clap</code> → 継続使用（CLIパーサー）</li>
</ul>
<h3 id="93-新規依存関係">9.3 新規依存関係</h3>
<ul>
<li><code>rusqlite</code> → データベース</li>
<li><code>serde</code> / <code>serde_json</code> → シリアライズ</li>
<li><code>prettytable-rs</code> → テーブル出力</li>
<li><code>bitstream-io</code> → TSパケット解析</li>
<li><code>tokio-rustls</code> → TLS通信</li>
<li><code>libloading</code> → DLL動的ロード（Windows）</li>
</ul>
<hr>
<h2 id="10-設計判断の根拠">10. 設計判断の根拠</h2>
<table>
<thead>
<tr>
<th>決定</th>
<th>理由</th>
</tr>
</thead>
<tbody>
<tr>
<td>ワークスペースレベル依存管理</td>
<td>複数crate間で依存競合を回避</td>
</tr>
<tr>
<td>Feature-gated TS解析</td>
<td>実HW依存テストを分離</td>
</tr>
<tr>
<td>EnumベースChannelType</td>
<td>既存コードと互換性確保</td>
</tr>
<tr>
<td>ロックフリーRingBuffer</td>
<td>高パフォーマンス・低遅延要件</td>
</tr>
<tr>
<td>TLS証明書認証</td>
<td>セキュリティ要件（企業ネットワーク対応）</td>
</tr>
<tr>
<td>データベース-backed チューニング</td>
<td>パフォーマンス・一貫性確保</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="11-リスクと緩和策">11. リスクと緩和策</h2>
<table>
<thead>
<tr>
<th>リスク</th>
<th>影響</th>
<th>緩和策</th>
</tr>
</thead>
<tbody>
<tr>
<td>依存関係競合</td>
<td>ビルド失敗</td>
<td>ワークスペースレベルで依存管理</td>
</tr>
<tr>
<td>TS解析が実HW依存</td>
<td>テスト不可能</td>
<td>シシミュレーションモード実装</td>
</tr>
<tr>
<td>プロキシパフォーマンス</td>
<td>遅延増大</td>
<td>リングバッファ+ロックフリー設計</td>
</tr>
<tr>
<td>データベーススケーラビリティ</td>
<td>パフォーマンス劣化</td>
<td>インデックス最適化、WALモード</td>
</tr>
<tr>
<td>TLS認証の複雑性</td>
<td>設定ミス</td>
<td>設定確認ツール、詳細ドキュメント</td>
</tr>
<tr>
<td>DLLバイナリサイズ</td>
<td>配布サイズ増大</td>
<td>依存関係最適化、stripping</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="12-使用例">12. 使用例</h2>
<h3 id="121-チャンネルスキャン">12.1 チャンネルスキャン</h3>
<pre><code class="language-bash"><span class="hljs-comment"># 基本スキャン</span>
recisdb scan --device BonDriver_XXXXXXXX.dll

<span class="hljs-comment"># カスタムDB位置</span>
recisdb scan --device BonDriver_XXXXXXXX.dll --database channels.db

<span class="hljs-comment"># 再構築</span>
recisdb scan --device BonDriver_XXXXXXXX.dll --recreate

<span class="hljs-comment"># ログ表示</span>
RUST_LOG=info recisdb scan --device BonDriver_XXXXXXXX.dll
</code></pre>
<h3 id="122-チャンネル表示">12.2 チャンネル表示</h3>
<pre><code class="language-bash"><span class="hljs-comment"># テーブル形式</span>
recisdb show --device BonDriver_XXXXXXXX.dll

<span class="hljs-comment"># JSON形式</span>
recisdb show --device BonDriver_XXXXXXXX.dll --format json
</code></pre>
<h3 id="123-チャンネルクエリ">12.3 チャンネルクエリ</h3>
<pre><code class="language-bash"><span class="hljs-comment"># クエリ（直接）</span>
recisdb query --device BonDriver_XXXXXXXX.dll --channel BS101

<span class="hljs-comment"># NID/SID/TSID指定</span>
recisdb query --device BonDriver_XXXXXXXX.dll --nid 0x0001 --sid 0x0001 --tsid 0x0000

<span class="hljs-comment"># マニュアル枝番指定</span>
recisdb query --device BonDriver_XXXXXXXX.dll --manual-sheet 1
</code></pre>
<h3 id="124-プロキシサーバー起動">12.4 プロキシサーバー起動</h3>
<pre><code class="language-bash"><span class="hljs-comment"># 基本起動</span>
cargo run -p recisdb-proxy -- --listen 0.0.0.0:12345

<span class="hljs-comment"># 設定ファイル使用</span>
cargo run -p recisdb-proxy -- --config /etc/recisdb-proxy/config.toml

<span class="hljs-comment"># デバッグモード</span>
RUST_LOG=debug cargo run -p recisdb-proxy -- --listen 0.0.0.0:12345 --tuner /dev/pt3video0
</code></pre>
<h3 id="125-tvtest連携">12.5 TVTest連携</h3>
<pre><code class="language-ini"><span class="hljs-comment">; BonDriver_NetworkProxy.ini</span>
<span class="hljs-section">[TLS]</span>
<span class="hljs-attr">Enabled</span>=<span class="hljs-number">1</span>
<span class="hljs-attr">CaCert</span>=C:\certs\ca.crt
<span class="hljs-attr">ClientCert</span>=C:\certs\client.crt
<span class="hljs-attr">ClientKey</span>=C:\certs\client.key

<span class="hljs-section">[Server]</span>
<span class="hljs-attr">Address</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">1.100</span>
<span class="hljs-attr">Port</span>=<span class="hljs-number">12345</span>
</code></pre>
<hr>
<h2 id="13-次のステップ">13. 次のステップ</h2>
<p>この計画書を承認いただいたら、Phase 0から実装を開始します。各フェーズの詳細な実装計画は、フェーズ開始時に作成します。</p>
<h3 id="承認が必要な事項">承認が必要な事項</h3>
<ol>
<li>既存コードの変更範囲</li>
<li>新規依存関係の追加</li>
<li>ビルド時間増加の許容</li>
<li>テスト環境の準備（実HW/HDD）</li>
</ol>
<hr>
<p><strong>計画書作成日</strong>: 2026/01/18
<strong>バージョン</strong>: 1.0</p>

            
            
        </body>
        </html>